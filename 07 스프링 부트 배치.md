07 스프링 부트 배치
======================= 
지금까지 개발한 커뮤니티 게시판을 실제로 운영한다고 가정합시다.        
점점 서비스는 커지고 시간이 흘러 사용자도 많아졌습니다.          
하지만 오랫동안 접속하지 않은 사용자도 꽤 늘었습니다.      
이런 사용자들은 휴면회원으로 전환해야겠습니다.      
휴면회원으로 백엔드에서 일괄 전환하는 기능을 지금까지 만든 프로젝트 중 어딘가에 추가해볼까 생각하니        
각자의 역할이 따로 있어서 마땅한 프로젝트가 없습니다.       
                
스프링 배치는 백엔드의 **배치 처리 기능**을 구현하는데 사용하는 프레임워크입니다.                
스프링 부트 배치는 스프링 배치의 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는데 도움을 줍니다.             
휴면회원 전환 기능은 일괄로 처리하는 것이 적절하므로 스프링 부트 배치를 활용하여 구현해보겠습니다.             

```
배치 : '프로그램의 흐름에 따라 순차적으로 자료를 처리한다'는 뜻입니다.   
배치 처리 : 일괄처리  
```
   
이 장에서는 스프링 부트 배치를 간단히 소개하고, 스프링 배치를 써야 하는 이유와 스프링 부트 배치 2.0 에 강화된 기능에 대해 알아봅니다.   
끝으로 휴먼회원 전환 기능을 직접 개발해봅니다.  
   
* 배경지식         
* 스프링 부트 배치 이해하기             
* 스프링 부트 휴먼회원 배치 설계하기       
* 스프링 부트 배치 설정하기     
* 스프링 부트 휴먼회원 배치 구현하기      
* 스프링 배치 심화학습      
* 멀티 스레드로 여러 개의 Step 실행하기   

# 1. 배경지식  
스프링 부트 배치는 스프링 본부인 피보탈과 컨설팅 회사인 액센츄어가 공동으로 개발했습니다.   
스프링에 관한 기술력을 갖고 있는 피보탈과 배치 처리 경험이 및 노하우로 효과적인 아키텍처를 구현할 수 있는 액센츄어의 합작품입니다.    
    
## 1.1. 배치 처리에 스프링 부트 배치를 사용해야 하는 이유     
**스프링 부트 배치 장점**   
* 대용량 데이터 처리에 최적화되어 고성능을 발휘합니다.       
* 효과적인 로깅, 통계처리, 트랜잭션 관리 등 재사용 가능한 필수 기능을 지원합니다.     
* 수동으로 처리하지 않도록 자동화되어 있습니다.      
* 예외사항과 비정상 동작에 대한 방어 기능이 있습니다.     
* 스프링 부트 배치의 반복되는 작업 프로세스를 이해하면 비즈니스 로직에 집중할 수 있습니다.      
    
백엔드에서 일어나는 배치 처리에 대한 대부분의 고민은 이미 스프링 부트 배치에서 기능으로 제공합니다.   
따라서 우리는 스프링 부트 배치의 기능을 잘 이해하고 효과적으로 사용하며 비즈니스 로직을 더욱 견고하게 작성하면 됩니다.    
   
## 1.2. 스프링 부트 배치 2.0   
스프링 부트 배치 2.0은 최신 버전인 스프링 배치 4.0을 기반으로 합니다. (2018년 기준)      
스프링 배치 4.0 은 다음 3가지 특성이 있습니다.      
    
1. 기본적으로 자바8 이상에서 동작합니다.       
자바8은 함수형 인터페이스와 람다를 지원해 한층 더 편리한 개발이 가능합니다.       
2. 스프링 프레임워크 5로 진화하면서 새롭게 재 배열된 의존성 트리를 지원합니다.       
3. ItemReaders, ItemProcessors, ItemWriters에 대한 빌더를 제공합니다.   

## 1.3. 스프링 부트 배치 주의사항  
스프링 부트 배치는 스프링 배치를 간편하게 사용할 수 있게 래핑한 프로젝트입니다.    
따라서 스프링 부트 배치와 스프링 배치 모두에서 다음과 같은 주의사항을 염두에 두기 바랍니다.    
  
1. 가능하면 단순화해서 복잡한 구조와 로직을 피해야합니다.       
2. 데이터를 직접 사용하는 작업이 번번하게 일어나므로 데이터 무결성을 유지하는 유효성 검사등의 방어책이 있어야합니다.        
3. 배치 처리 시 시스템 I/O 사용을 최소화해야 합니다.            
잦은 I/O 로 데이터베이스 커넥션과 네트워크 비용이 커지면 성능에 영향을 줄 수 있기 때문입니다.        
따라서 가능하면 한번에 데이터를 조회하여 메모리에 저장해두고 처리를 한 다음, 그 결과를 한번에 데이터베이스에 저장하는 것이 좋습니다.              
4. 일반적으로 같은 서비스에 사용되는 웹,API,배치,기타 프로젝트들은 서로 영향을 줍니다.        
따라서 배치 처리가 진행되는 동안 다른 프로젝트 요소에 영향을 주는 경우가 없는지 주의를 기울여야 합니다.       
5. 스프링 부트 배치는 스케줄러를 제공하지 않습니다.         
배치 처리 기능만 제공하며 스케줄링 기능은 스프링에서 제공하는 쿼츠 프레임워크, IBM 티볼리 스케줄러, BMC 컨트롤 등을 이용해야 합니다.          
리눅스 crontab 명령은 가장 간단히 사용할 수 있지만 이는 추천하지 않습니다.     
crontab의 경우 각 서버마다 따로 스케줄링을 관리해야 하며 무엇보다 클러스터링 기능이 제공되지 않습니다.       
반면에 쿼츠와 같은 스케줄링 프레임워크를 사용한다면 클러스터링뿐만 아니라 다양한 스케줄링 기능, 실행 이력 관리등 여러 이점을 얻을 수 있습니다.     

***
# 2. 스프링 부트 배치 이해하기   
스프링 부트 배치가 2.0으로 업그레이드되었지만 여전히 일반적인 배치 처리 절차를 따릅니다.    
배치의 일반적인 시나리오는 다음과 같은 3단계로 이루어집니다.   

1. 읽기 : 데이터 저장소(일반적으로 데이터베이스)에서 특정 데이터 레코드를 읽습니다.   
2. 처리 : 원하는 방식으로 데이터를 가공/처리합니다.   
3. 쓰기 : 수정된 데이터를 다시 저장소(데이터베이스)에 저장합니다.      
     
즉, 배치 처리는 읽기 -> 처리 -> 쓰기 흐름을 갖습니다.     
그렇다면 스프링에서는 이러한 배치처리의 흐름을 어떻게 구현했는지 알아보겠습니다.      
다음 그림은 배치 처리와 관련된 객체의 관계를 보여줍니다.        
   
[사진]      
   
Job과 Step은 1:M, Step과 ItemReader, ItemPeocessor, ItemWriter는 1:1 관계를 가집니다.   
즉, Job 이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현합니다.    

## 2.1. Job
Job은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체입니다.   
또한 전체 배치 처리에 있어 항상 최상단 계층에 있습니다.   
위에서 하나의 Job(일감) 안에는 여러 Step(단계)이 있다고 설명했던 바와 같이   
스프링 배치에서 Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너입니다.

```
인스턴스 : 객체 지향 프로그래밍(OOP)에서 해당 클래스의 구조로 컴츄터 저장공간에 할당된 실체를 의미합니다.   
OOP 에서 객체는 클래스와 인스턴스를 포함하는 개념입니다.  
```   
   
Job 객체를 만드는 빌더는 여러 개 있습니다.   
여러 빌더를 통합 처리하는 공장인 JobBuilderFactory로 원하는 Job을 손쉽게 만들 수 있습니다.   
JobBuilderFactory의 ```get()``` 메서드로 JobBuilder를 생성하고 이를 이용합니다.   
   
___  
   
JobBuilderFactory 부터 봅시다. (스프링 배치 라이브러리에 포함되어 있다.  )

**JobBuilderFactory**
```java
```
JobBuilderFactory는 JobBuilder를 생성할 수 있는 get() 메서드를 포함하고 있습니다.     
get() 메서드 내부를 들여다보면 JobBuilderFactory가 새로운 JobBuilder를 생성해서 반환하는 것을 확인할 수 있습니다.     
JobBuilderFactory 에 get() 메서드를 호출할 때마다 새로운 빌더가 생성되는 것입니다.   
   
게다가 새로운 JobBuilder를 생성할 때마다      
당초 JobBuilderFactory가 생성될 때 주입 받은 JobRepository를 JobBuilder에서 사용할 리포지토리로 설정합니다.           
해당 JobBuilderFactory에서 생성되는 모든 JobBuilder가 동일한 리포지토리를 사용하는 것입니다.        
       
___    
    
JobBuilderFactory는 앞서 설명한 바와 같이 JobBuilder를 생성하는 역할만 수행합니다.   
이렇게 생성된 JobBuilder를 이용해서 Job을 생성해야 하는데,  
그렇다면 JobBuilder의 역할은 무엇인지 JobBuilder의 메서드를 통해 기능을 알아보겠습니다.   

**JobBuilder의 일부**
```java
public SimpleJobBuilder start(Step step){
  return new SimpleJobBuilder(this).start(step);
}

public JobFlowBuilder start(Flow flow){
  return new JobFlowBuilder(this).start(flow);
}

public JobFlowBuilder start(Step step){
  return new JobFlowBuilder(this).start(step);
}
```

___

```java
public SimpleJobBuilder start(Step step){
  return new SimpleJobBuilder(this).start(step);
}
```
Step을 추가해서 가장 기본이 되는 SimpleJobBuilder를 생성합니다.   
   
___

```java
public JobFlowBuilder start(Flow flow){
  return new JobFlowBuilder(this).start(flow);
}
```
Flow를 실행할 JobFlowBuilder를 생성합니다.   

___

```java
public JobFlowBuilder start(Step step){
  return new JobFlowBuilder(this).start(step);
}
```
Step을 실행할 JobFlowBuilder를 생성합니다.     
  
___
 
JobBuilder의 메서드를 살펴보니 모두 반환 타입이 빌더입니다.     
JobBuilder는 직접적으로 Job을 생성하는 것이 아니라 별도의 구체적인 빌더를 생성하여 반환합니다.          
   
왜 이렇게 별도의 빌더를 생성하게 끔 구현되어 있을까요?     
경우에 따라 Job 생성 방법이 모두 다르기 때문에 별도의 구체적인 빌더를 구현하고 이를 통해 Job 생성이 이루어지게 하려는 의도록 파악됩니다.     
중간에 빌더를 한번 더 반환받아 사용해야 하므로 불편할 수 있다는 생각이 들지도 모르겠지만      
메서드 체인 방식을 활용하면 구체적인 빌더의 존재를 생각하지 않아도 될 만큼 손쉽게 처리할 수 있습니다.     
      
메서드를 좀더 자세히 살펴보면 Job을 생성하기 위한 Step 또는 Flow를 파라미터로 받아 구체적인 빌더를 생성합니다.         
Job은 Step 또는 Flow 인스턴스의 컨테이너 역할을 하기 때문에 생성하기 전에 인스턴스를 전달받습니다.        
     
___   
       
그럼 JobBuilder로 가장 간단하게 만들 수 있는 빌더인 SimpleJobBuilder를 이용해 Job을 생성해봅시다. 

**예시**
```java
@Autowired  
private JobBuilderFactory jobBuilderFactory;

@Bean
public Job simpleJob(){
  return jobBuilderFactory.get("simpleJob")
    .start(simpleStep());
    .build();
}
```
JobBuilderFactory의 get() 메서드에 ```"simpleJob"``` 문자열을 파라미터로 넘기면    
```"simpleJob"```이라는 이름을 가진 Job을 생성할 수 있는 JobBuilder 객체 인스턴스가 반환됩니다.   
여기서 simpleStep() 메서드는 아주 간단한 Step 인스턴스를 생성하여 반환하는 메서드라 가정하면 결국 
결국 start() 메서드로 인해 생성되는 빌더는 SimpleJobBuilder입니다.   
마지막으로 SimpleJobBuilder의 build() 메서드를 호출하여 빌드하면 비로소 simpleJob 이라는 이름을 가진 Job이 생성되어 반환됩니다.   
(메서드 체인 방식을 이용한 것을 알 수 있다.)      
       
## 2.2. JobInstance   
JobInstance는 배치에서 Job이 실행될 때 하나의 Job 실행 단위입니다.   
만약 하루에 한 번씩 배치의 Job이 실행된다면 어제와 오늘 실행한 각각의 Job을 JobInstance라고 부를 수 있습니다.     
그렇다면 각각의 JobInstance는 하나의 JobExecution(JobInstance에 대한 한번의 실행을 나타내는 객체)을 갖고 있을 까요?  
**아닙니다.**   
오늘 Job을 실행했는데 실패했다면 다음날 동일한 JobInstance를 가지고 또 실행합니다.    
Job 실행이 실패하면 JobInstance가 끝난 것으로 간주하지 않기 때문입니다.    
그러면 JobInstance는 어제의 실패한 JobExecution과 오늘의 성공한 JobExecution 두 개를 가지게 됩니다.    
즉, JobInstance는 JobExecution 을 여러 개 가질 수 있습니다.    
         
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
