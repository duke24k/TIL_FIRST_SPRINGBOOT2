07 스프링 부트 배치
======================= 
지금까지 개발한 커뮤니티 게시판을 실제로 운영한다고 가정합시다.        
점점 서비스는 커지고 시간이 흘러 사용자도 많아졌습니다.          
하지만 오랫동안 접속하지 않은 사용자도 꽤 늘었습니다.      
이런 사용자들은 휴면회원으로 전환해야겠습니다.      
휴면회원으로 백엔드에서 일괄 전환하는 기능을 지금까지 만든 프로젝트 중 어딘가에 추가해볼까 생각하니        
각자의 역할이 따로 있어서 마땅한 프로젝트가 없습니다.       
                
스프링 배치는 백엔드의 **배치 처리 기능**을 구현하는데 사용하는 프레임워크입니다.                
스프링 부트 배치는 스프링 배치의 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는데 도움을 줍니다.             
휴면회원 전환 기능은 일괄로 처리하는 것이 적절하므로 스프링 부트 배치를 활용하여 구현해보겠습니다.             

```
배치 : '프로그램의 흐름에 따라 순차적으로 자료를 처리한다'는 뜻입니다.   
배치 처리 : 일괄처리  
```
   
이 장에서는 스프링 부트 배치를 간단히 소개하고, 스프링 배치를 써야 하는 이유와 스프링 부트 배치 2.0 에 강화된 기능에 대해 알아봅니다.   
끝으로 휴먼회원 전환 기능을 직접 개발해봅니다.  
   
* 배경지식         
* 스프링 부트 배치 이해하기             
* 스프링 부트 휴먼회원 배치 설계하기       
* 스프링 부트 배치 설정하기     
* 스프링 부트 휴먼회원 배치 구현하기      
* 스프링 배치 심화학습      
* 멀티 스레드로 여러 개의 Step 실행하기   

# 1. 배경지식  
스프링 부트 배치는 스프링 본부인 피보탈과 컨설팅 회사인 액센츄어가 공동으로 개발했습니다.   
스프링에 관한 기술력을 갖고 있는 피보탈과 배치 처리 경험이 및 노하우로 효과적인 아키텍처를 구현할 수 있는 액센츄어의 합작품입니다.    
    
## 1.1. 배치 처리에 스프링 부트 배치를 사용해야 하는 이유     
**스프링 부트 배치 장점**   
* 대용량 데이터 처리에 최적화되어 고성능을 발휘합니다.       
* 효과적인 로깅, 통계처리, 트랜잭션 관리 등 재사용 가능한 필수 기능을 지원합니다.     
* 수동으로 처리하지 않도록 자동화되어 있습니다.      
* 예외사항과 비정상 동작에 대한 방어 기능이 있습니다.     
* 스프링 부트 배치의 반복되는 작업 프로세스를 이해하면 비즈니스 로직에 집중할 수 있습니다.      
    
백엔드에서 일어나는 배치 처리에 대한 대부분의 고민은 이미 스프링 부트 배치에서 기능으로 제공합니다.   
따라서 우리는 스프링 부트 배치의 기능을 잘 이해하고 효과적으로 사용하며 비즈니스 로직을 더욱 견고하게 작성하면 됩니다.    
   
## 1.2. 스프링 부트 배치 2.0   
스프링 부트 배치 2.0은 최신 버전인 스프링 배치 4.0을 기반으로 합니다. (2018년 기준)      
스프링 배치 4.0 은 다음 3가지 특성이 있습니다.      
    
1. 기본적으로 자바8 이상에서 동작합니다.       
자바8은 함수형 인터페이스와 람다를 지원해 한층 더 편리한 개발이 가능합니다.       
2. 스프링 프레임워크 5로 진화하면서 새롭게 재 배열된 의존성 트리를 지원합니다.       
3. ItemReaders, ItemProcessors, ItemWriters에 대한 빌더를 제공합니다.   

## 1.3. 스프링 부트 배치 주의사항  
스프링 부트 배치는 스프링 배치를 간편하게 사용할 수 있게 래핑한 프로젝트입니다.    
따라서 스프링 부트 배치와 스프링 배치 모두에서 다음과 같은 주의사항을 염두에 두기 바랍니다.    
  
1. 가능하면 단순화해서 복잡한 구조와 로직을 피해야합니다.       
2. 데이터를 직접 사용하는 작업이 번번하게 일어나므로 데이터 무결성을 유지하는 유효성 검사등의 방어책이 있어야합니다.        
3. 배치 처리 시 시스템 I/O 사용을 최소화해야 합니다.            
잦은 I/O 로 데이터베이스 커넥션과 네트워크 비용이 커지면 성능에 영향을 줄 수 있기 때문입니다.        
따라서 가능하면 한번에 데이터를 조회하여 메모리에 저장해두고 처리를 한 다음, 그 결과를 한번에 데이터베이스에 저장하는 것이 좋습니다.              
4. 일반적으로 같은 서비스에 사용되는 웹,API,배치,기타 프로젝트들은 서로 영향을 줍니다.        
따라서 배치 처리가 진행되는 동안 다른 프로젝트 요소에 영향을 주는 경우가 없는지 주의를 기울여야 합니다.       
5. 스프링 부트 배치는 스케줄러를 제공하지 않습니다.         
배치 처리 기능만 제공하며 스케줄링 기능은 스프링에서 제공하는 쿼츠 프레임워크, IBM 티볼리 스케줄러, BMC 컨트롤 등을 이용해야 합니다.          
리눅스 crontab 명령은 가장 간단히 사용할 수 있지만 이는 추천하지 않습니다.     
crontab의 경우 각 서버마다 따로 스케줄링을 관리해야 하며 무엇보다 클러스터링 기능이 제공되지 않습니다.       
반면에 쿼츠와 같은 스케줄링 프레임워크를 사용한다면 클러스터링뿐만 아니라 다양한 스케줄링 기능, 실행 이력 관리등 여러 이점을 얻을 수 있습니다.     

***
# 2. 스프링 부트 배치 이해하기   
스프링 부트 배치가 2.0으로 업그레이드되었지만 여전히 일반적인 배치 처리 절차를 따릅니다.    
배치의 일반적인 시나리오는 다음과 같은 3단계로 이루어집니다.   

1. 읽기 : 데이터 저장소(일반적으로 데이터베이스)에서 특정 데이터 레코드를 읽습니다.   
2. 처리 : 원하는 방식으로 데이터를 가공/처리합니다.   
3. 쓰기 : 수정된 데이터를 다시 저장소(데이터베이스)에 저장합니다.      
     
즉, 배치 처리는 읽기 -> 처리 -> 쓰기 흐름을 갖습니다.     
그렇다면 스프링에서는 이러한 배치처리의 흐름을 어떻게 구현했는지 알아보겠습니다.      
다음 그림은 배치 처리와 관련된 객체의 관계를 보여줍니다.        
   
[사진]      
   
Job과 Step은 1:M, Step과 ItemReader, ItemPeocessor, ItemWriter는 1:1 관계를 가집니다.   
즉, Job 이라는 하나의 큰 일감(Job)에 여러 단계(Step)를 두고, 각 단계를 배치의 기본 흐름대로 구현합니다.    

## 2.1. Job
Job은 배치 처리 과정을 하나의 단위로 만들어 표현한 객체입니다.   
또한 전체 배치 처리에 있어 항상 최상단 계층에 있습니다.   
위에서 하나의 Job(일감) 안에는 여러 Step(단계)이 있다고 설명했던 바와 같이   
스프링 배치에서 Job 객체는 여러       
위에서 하나의 Job(일감) 안에는 여러 Step    
### 2.1.1. 내용1
```
내용1
```   

***
# 3. 대주제
> 인용
## 3.1. 소 주제
### 3.1.1. 내용1
```
내용1
```
