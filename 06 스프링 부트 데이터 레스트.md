06 스프링 부트 데이터 레스트
=======================
시대가 변하면서 다양한 브라우저와 모바일 기기가 탄생하고 있습니다.       
이러한 다양한 기기들을 단일 서버로 데이터를 관리하여 유연하게 클라이언트 영역을 대응할 수 있는 방법이 있는데, 바로 REST 서버입니다.     
클라이언트는 단지 REST 서버를 통해 데이터를 받아와서 각 기기별로 대응하면 됩니다.         
     
REST는 웹의 장점을 극대화하는 통신 네트워크 아키텍처입니다.        
REST의 구현 원칙을 제대로 지키는 시스템을 RESTful 이라고 합니다.         
현재 웹에서 사용하는 대부분의 데이터 통신이 REST API라고 해도 과언이 아닙니다.      
      
그런데 REST API를 개발하는 작업은 반복적이며 지루합니다.    
또한 원칙을 제대로 지키지 못하는 경우가 부지기수입니다.       
다행히도 스프링 부트는 REST API의 규격을 지키면서 빠르게 REST API를 개발할 수 있는 스타터를 제공해줍니다.      
    
이제부터 REST API를 기존의 MVC 패턴으로 만들어보고,       
스프링 부트 데이터 레스트를 사용하여 개발해본 후 어떻게 다른지 알아보겠보겠습니다.     
   
# 1. 배경지식  
## 1.1. REST 소개    
REST 는 웹과 같은 분산 하이퍼미디어 시스템에서 사용하는 통신 네트워크 아키텍처로, 네트워크 아키텍처의 원리 모음입니다.       
          
웹은 전송 방식으로 HTTP, 식별 방법으로 URI를 사용합니다.          
HTTP는 웹에서 GET, POST, PUT, DELETE 등의 메소드를 사용하여 정보를 주고받는 프로토콜입니다.           
REST는 HTTP 와 URI의 단순하고 간결한 장점을 계승화한 네트워크 아키텍처입니다.            
따라서 다양한 요구사항에 대응하여 때로는 단순하게, 때로는 서버와 클라이언트가 서로 통신하는 리소스에 대해 복잡한 방식으로 상호작용할 수 있습니다.                 
        
REST는 다음과 같은 목적으로 만들어졌습니다.      
        
* 구성요소 상호작용의 규모 확장성        
* 인터페이스 범용성            
* 구성요소의 독립적인 배포          
* 중간적 구성요소를 이용한 응답 지연 감소, 보안 강화, 레거시 시스템 인캡슐레이션      
 
**URI(Uniform Resouce Identifier, 통합자원식별자)**    
```
URI(Uniform Resouce Identifier, 통합자원식별자)는 인터넷에서 특정 자원을 나타내는 유일한 주솟값입니다.   
REST API 는 URI를 사용하여 자원을 처리합니다.     
```

## 1.2. RESTful 제약조건    
앞서 REST의 구현 원칙을 제대로 지키면서 REST 아키텍처를 만드는 것을 RESTful 이라고 설명했습니다.          
다음은 RESTful 제약조건입니다.         
      
* **클라이언트-서버** :           
이 제약 조건의 기본 원칙은 관심사의 명확한 분리입니다.          
관심사의 명확한 분리가 선행되면 서버의 구성요소가 단순화되고 확장성이 향상되어 여러 플랫폼을 지원할 수 있습니다.          
         
* **무상태성** :        
서버에 클라이언트의 상태 정보를 저장하지 않는 것을 의미합니다.             
단순히 들어오는 요청만 처리하여 구현을 더 단순화 합니다.         
단, 클라이언트의 모든 요청은 서버가 요청을 알아듣는데 필요한 모든 정보를 담고 있어야 합니다.        
      
* **캐시 기능** :     
클라이언트의 응답을 캐시할 수 있어야 합니다.       
앞에서 HTTP의 장점을 그대로 계승한 아키택처가 REST라고 했습니다.        
따라서 HTTP의 캐시 기능도 적용할 수 있습니다.      
       
* **계층화 시스템** :       
서버는 중계 서버(게이트웨이, 프록시)나 로드 밸런싱, 공유 캐시등의 기능을 사용하여 확장성 있는 시스템을 구성할 수 있습니다.        
이 제약조건은 선택적 제약 조건입니다.       
    
* **코드 온 디맨드** :   
클라이언트는 서버에서 자바 애플릿, 자바스크립트 같은 실행 코드를 전송받아 기능을 일시적으로 확장할 수 있습니다.   
이 제약조건은 선택적 제약 조건입니다.         
    
* **인터페이스 일관성** :    
URI로 지정된 리소스에 균일하고 통일된 인터페이스를 제공합니다.         
아키텍처를 단순하게 분리하여 단순하게 만들 수 있습니다.      

### 1.2.1. 인터페이스 일관성        
인터페이스 일관성은 세부 원칙을 가지고 있습니다.       
인터페이스 일관성이 잘 지켜졌는지에 따라 REST를 제대로 사용했는지 판단할 수 있습니다.      
인터페이스 일관성에는 다음 4가지가 존재합니다.        
         
1. 자원 식별                  
2. 메시지를 통한 리소스 조작             
3. 자기 서술적 메시지           
4. 애플리케이션 상태에 대한 엔진으로서의 하이퍼미디어               
    
___ 
    
**자원 식별** :          
웹 기반의 REST에서 리소스 접근을 주로 URI를 사용한다는 것을 나타냅니다.         
즉, 각각의 리소스는 요청에서 식별가능합니다.        
 
```
http://localhost:8080/resource/1
```
예를 들어 URI에서 정보는 ```resouce```, 유일한 구분자는 ```1```로 식별합니다.         
   
___
   
**메시지를 통한 리소스 조작** :       
클라이언트가 특정 메시지나 메타데이터를 가지고 있으면 자원을 수정, 삭제하는 충분한 정보를 갖고 있는 것으로 볼 수 있습니다.       

```
http://localhost:8080/resource/1
content-type: application/json    
```   
예를 들어 코드에서 ```content-type``` 은 리소스가 어떤 형식인지 지정합니다.    
리소스는 HTML, XML, JSON 등 다양한 형식으로 전송됩니다.     
    
___    
        
**자기 서술적 메시지** :    
각 메시지는 자신을 어떻게 처리해야 하는지 충분한 정보를 포함해야 합니다.     
웹 기반의 REST에서는 HTPP Method 와 Header 를 활용합니다.       

```
GET http://localhost:8080/resource/1     
content-type: application/json    
```   
예를 들어 GET 메서드를 활용하여 ```/resource/1```의 정보를 받아온다는 것을 표현했습니다.     
    
___    
    
**HATEOAS** :     
애플리케이션 상태에 대한 엔진으로서의 하이퍼 미디어      
이는 클라이언트에 응답할 때 단순히 결과 데이터만 제공해주기보다는 URI를 함께 제공해야한다는 원칙입니다.    
하이퍼텍스트 링크처럼 관련된 리소스 정보를 포합합니다. 이에 관한 정보는 ```(링크 걸기)[#]``` 에서 확인합시다.      
    
REST의 제약조건들을 제대로 지키면서 REST 아키텍처를 만드는 것을 RESTful 이라고 합니다.    
특히 제약 조건 중 하이퍼텍스트를 포함하고 자기 서술적이며 인터페이스 일관성을 통해 리소스에 접근하는 API여야 RESTFful 하다 할 수 있습니다.  
더 쉽게 말해서 인터페이스가 일관된 표준이 있어야합니다.       
자기 자신이 어떻게 처리되는지에 대한 충분한 정보, 관련된 리소스를 하이퍼텍스트 링크로 포함시켜야 'RESTful 하구나' 생각할 수 있습니다.         
여기서 HATEOAS는 응답 데이터와 관련된 하이퍼미디어 링크를 추가하여 사이트의 REST 인터페이스를 동적으로 탐색하도록 도와줍니다.       
       
* 클라이언트는 관련된 특정 동작에 따라 탐색할 만한 URI 값을 알 수 있습니다.       
URI는 resource 까지 포함하므로 더 명확하게 예측이 가능합니다.        
     
* 키 값이 변하지 않는 한 URI가 변경되더라도 동적으로 사용할 수 있습니다.         
따라서 서버쪽 코드가 변하더라도 클라이언트 코드를 따로 수정할 필요가 없습니다.      


## 1.3. REST API 설계하기    
서버 한대가 여러 클라이언트에 대응하려면 REST API가 필요합니다.     
REST API는 다음과 같이 구성합니다.      
     
* 자원 : URI   
* 행위 : HTTP 메서드   
* 표현 : 리소스에 대한 표현 (HTTP Message Body)       

### 1.3.1. URI 설계    
URI는 URL을 포함하는 개념입니다.      
      
**URL(Uniform Resouce Locator, 파일식별자)**   
```
URL(Uniform Resouce Locator, 파일식별자) 은 인터넷상에서 자원, 즉 특정 파일이 어디에 위치하는지 식별하는 방법입니다.   
```

**URL 예시**   
```  
http://localhost:8080/api/book.pdf      
```  
URL은 웹상의 파일 위치를 표현합니다.    
    
**URI 예시**   
```  
http://localhost:8080/api/book/1         
```   
URI는 웹에 있는 자원의 이름과 위치를 식별합니다.       
   
그렇기에 URL은 URI의 하위 개념입니다.    
URL이 리소스를 가져오는 방법에 대한 위치라면 URI는 문자열을 식별하기 위한 표준입니다.      
     
___
    
```
http://localhost:8080/api/read/books   
```   
URI은 명사를 사용해야 하며 동사를 피해야합니다.          
위 같은 코드는 ```/read/```라는 동사가 들어 있으므로 좋지 못한 코드라고 할 수 있습니다.   
   
```
GET http://localhost:8080/api/books   
content-type: application/json
```    
이처럼 동사를 표현할 때는 HTTP 메서드인 GET, POST, PUT, DELETE 등으로 대체해야 합니다.         
하지만 모든 경우에 완벽하게 호환되지는 않습니다.       
세부적인 동사의 경우 URI에 포함될 수 밖에 없습니다.        
가령 모바일 결제라는 REST API를 설계한다고 가정할 경우 OTP 발행, 결제 진행, 기타 API 동작에 대해 HTTP 메서드만으로 대응하기 힘듭니다.     
앞의 URI 설계에 대한 원칙은 어디까지나 불필요한 동사를 URI에 포함하는 것을 지양해야 한다는 것이지 완전히 배제시킨다는 것은 아닙니다.   
    
### 1.3.2. 복수형을 사용해라     
URI에서는 명사에 단수형보다는 복수형을 사용해야 합니다.        
```/book```도 물론 명사고 사용가능하지만       
```/books```로 리소스를 표현하면 컬렉션으로 명확하게 표현할 수 있어 확장성 측면에서 더 좋습니다.     
주로 사용되는 인터페이스는 Set, List, Queue, Deque입니다.         
이러한 컬렉션은 객체의 단일 단위, 즉 그룹을 나타냅니다.      
  
```javascript    
{
     books: [
          {
               book: ...
          },
          {
               book: ...
          },
          {
               book: ...
          },
     ]
}
```
그리고 컬렉션으로 URI를 사용할 경우 컬렉션을 한번 더 감싼 중첩 형식을 사용하는 것이 좋습니다.    
만약 중첩하지 않고 바로 컬렉션을 반환하면 추후 수정할 때나 확장할 때 번거롭게 됩니다.    
      
예를 들어 중첩하지 않고 하나의 ```books``` 컬렉션만 보내는 도중 다른 요구사항이 있다고 가정합시다.    
요구사항이 전혀 다른 ```stores``` 컬렉션을 추가하는 겁니다.    
기존의 형태가 ```키값 + 컬렉션``` 으로 중첩된 형태가 아니기 때문에 ```stores``` 컬렉션을 추가하기 위해 기존의 형태가 깨지게 됩니다.     
그렇게 되면 서버에서 API 스펙을 수정하게 되고 클라이언트도 수정된 API 스펙에 맞게 코드를 수정해야합니다.   

```javascript   
{
     _embedded: [
          {
               books: [
                    {
                         book: ...
                    },
                    {
                         book: ...
                    },
                    {
                         book: ...
                    },
               ]
          },
          {
               stores: [
                    {
                         store: ...
                    },
                    {
                         store: ...
                    },
                    {
                         store: ...
                    },
               ]
          }          
     ]
}
```
위 코드는 앞서 말한 방식대로 작성한 코드입니다.       
```-embedded : []``` 내부에 기존 컬레션의 키 값이 유지되게 보낼 경우        
서버의 API 스펙이 변경되더라도 클라이언트는 따로 코드를 수정할 필요가 없습니다.      
   
이렇게 확장성을 나타내는 (중첩 형태를 나타내는) ```_embedded```로 데이터를 감싸서 여러 키값을 한번에 보낼 수 있습니다.      
이런 형식을 유지하면 뒤늦게 데이터가 추가되어도 기존에 제공한 ```books``` 데이터와 관련된 부분을 수정하지 않아도 됩니다.           
    
### 1.3.3. 행위 설계   
```books```의 동사 부분을 HTTP 메서드를 사용하여 표현하면 다음과 같습니다.      
     
[사진]   
   
```/books```의 경우 book의 목록을 표현한다는 기본 전제가 깔려있습니다.         
따라서 ```/books```로 URI를 표현하면 기본적으로 복수를 나타내며 작게는 하나의 단위를 나타낼 수 있게 됩니다.        
즉, ```/books/{단일값}```은 books 의 목록 중 특정 book을 사용합니다.        
이제 원하는 행위에 따라 동사를 선택적으로 사용합니다.        
    
```/books``` 자체가 복수의 book을 의미하므로 books를 게시판에 표현할 때 페이징을 처리하는 값을 추가로 제공할 수도 있습니다.    
추가 값으로 페이지, 크기, 정렬, 등의 파라미터를 지정할 수 있습니다.      
아래와 같이 JPA의 Pageable의 프로퍼티 값을 그대로 사용할 수 있습니다.      

```
GET http://localhost:8080/api/books?page=0&size=10&sort=desc
content-type: application/json    
```    
page, size, sort 파라미터를 따로 지정하지 않으면 서버에서 기본으로 설정한 값으로 반환됩니다.   
    
**POST** 는 book 하나를 새로 생성하여 저장하는 역할을 수행합니다.         
생성할 book 객체에는 아직 ID 값이 없으므로 ```/books```에서 POST를 요청하는 형태로 API가 설계됩니다.             
 
**PUT** 은 특정 book 객체를 수정할 때 사용하며 ID값이 있으므로 ID값을 대상으로 진행합니다.            
  
**DELETE** 는 특정 book 객체를 삭제할 때 사용하며 ID값이 있으므로 ID값을 대상으로 진행합니다.           
     
***    
# 2. 설계하기   
REST API 를 MVC 패턴을 이용한 방법과 스프링부트 데이터 레스트를 사용하는 방법으로 구현해보겠습니다.      
두 방법을 모두 다루는 이유는 각 방식의 장단점을 체험하며 비교해보기 위해서입니다.      
      
[사진]     
   
생동감 있는 프로젝트 진행을 위해 4장에서 다룬 게시판 프로젝트에서         
미완으로 남겨두었던 생성/수정/삭제 기능을 REST API로 개발하여 서로 연동하겠습니다.         
   
사진을 보면 클라이언트 DB가 기존에는 (1)과 같이 직접 데이터를 주고 받았습니다.          
REST API를 사용하면 (2),(3)과 같이 클라이언트와 DB 사이클 REST API가 중계하게 됩니다.       
이러한 구조는 REST API에서 노출하고 싶은 데이터만 노출할 수 있으며       
데이터를 캐시하여 성능도 향상되는 구조까지 가질 수 있습니다.      
따라서 기존에 직접 데이터를 주고받던 과정은 사라집니다.     
즉 (1)의 흐름은 없어집니다.      

## 2.1. MVC 패턴을 활용하는 방법     
MVC 패턴으로 프로젝트를 생성하면 컨트롤러, 서비스, 레포지토리로 나누어 데이터의 운반 처리를 세부적으로 조작할 수 있습니다.      
기존의 웹과 거의 차이가 없고 단지 데이터의 반환 형태가 HTML 이냐 JSON,XML 등의 형태냐의 차이입니다.      
내부 구성을 도식화하면 다음과 같습니다.    
       
[사진]        
    
## 2.2. 스프링 부트 데이터 레스트를 활용하는 방법      
스프링 부트 데이터 레스트는 리포지토리 하나만 생성하면 됩니다.       
MVC 패턴을 활용한 방식과 달리 컨트롤러와 서비스 단계가 없습니다.         
필요하다면 생성하여 사용할 수도 있는데 이는 ```(링크)[]```에서 살펴보겠습니다.         
       
스프링 부트 데이터 레스트는 REST URL 요청을 리포지토리 내부의 CRUD 메서드와 매핑하여 처리합니다.       
즉 처리 영역들이 스프링 부트 데이터 레스트 라이브러리 내부에 미리 만들어져 있어 컨트롤러와 서비스 영역을 자동화할 수 있습니다.    
따라서 다음과 같이 간단하게 REST API를 사용하는 애플리케이션을 설계할 수 있습니다.       
    
[사진]   

# 3. 스프링 부트 MVC 패턴으로 REST API 구현하기       

1. 클라이언트와 REST API의 통신을 위한 클라이언트 쪽 스크립트 코드 추가  
2. REST API 개발 환경 설정   
3. CORS 허용 및 시큐리티 설정   
4. 생성, 수정, 삭제 기능 구현 

## 3.1. 준비하기            
커뮤니티 게시판과 연동하려면 클라이언트 쪽에 자바스크립트로 통신용 코드를 구현해야합니다.             
여기서 생성/수정/삭제에 대한 요청을 AJAX 로 하면 비동기로 서버와 통신할 수 있으므로 페이지 변화 없이 데이터를 요청하여 응답받고 대응하는 코드를 추가할 수 있습니다.              
다음과 같이 AJAX로 코드를 작성하겠습니다.           
    
**form.html**
```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Board Form</title>
    <link rel="stylesheet" th:href="@{/css/base.css}" />
    <link rel="stylesheet" th:href="@{/css/bootstrap.min.css}" />
</head>
<body>
    <div th:replace="layout/header::header"></div>

    <div class="container">
        <div class="page-header">
            <h1>게시글 등록</h1>
        </div>
        <br/>
        <input id="board_idx" type="hidden" th:value="${board?.idx}"/>
        <input id="board_create_date" type="hidden" th:value="${board?.createdDate}"/>
        <table class="table">
            <tr>
                <th style="padding:13px 0 0 15px">게시판 선택</th>
                <td>
                    <div class="pull-left">
                        <select class="form-control input-sm" id="board_type">
                            <option>--분류--</option>
                            <option th:value="notice" th:selected="${board?.boardType?.name() == 'notice'}">공지사항</option>
                            <option th:value="free" th:selected="${board?.boardType?.name() == 'free'}">자유게시판</option>
                        </select>
                    </div>
                </td>
            </tr>
            <tr>
                <th style="padding:13px 0 0 15px;">생성날짜</th>
                <td><input type="text" class="col-md-1 form-control input-sm" readonly="readonly" th:value="${board?.createdDate} ? ${#temporals.format(board.createdDate,'yyyy-MM-dd HH:mm')} : ${board?.createdDate}"/></td>
            </tr>
            <tr>
                <th style="padding:13px 0 0 15px;">제목</th>
                <td><input id="board_title" type="text" class="col-md-1 form-control input-sm" th:value="${board?.title}"/></td>
            </tr>
            <tr>
                <th style="padding:13px 0 0 15px;">부제목</th>
                <td><input id="board_sub_title" type="text" class="col-md-1 form-control input-sm" th:value="${board?.subTitle}"/></td>
            </tr>
            <tr>
                <th style="padding:13px 0 0 15px;">내용</th>
                <td><textarea id="board_content" class="col-md-1 form-control input-sm" maxlength="140" rows="7" style="height: 200px;"
                th:text="${board?.content}"></textarea><span class="help-block"></span>
                </td>
            </tr>
            <tr>
                <td></td>
                <td></td>
            </tr>
        </table>
        <div class="pull-left">
            <a href="/board/list" class="btn btn-default">목록으로</a>
        </div>
        <div class="pull-right">
            <button th:if="!${board?.idx}" type="button" class="btn btn-primary" id="insert">저장</button>
            <button th:if="${board?.idx}" type="button" class="btn btn-info" id="update">수정</button>
            <button th:if="${board?.idx}" type="button" class="btn btn-danger" id="delete">삭제</button>
        </div>
    </div>

    <div th:replace="layout/footer::footer"></div>

    <script th:src="@{/js/jquery.min.js}"></script>
    <script th:if="!${board?.idx}">
        $('#insert').click(function () {
            var jsonData = JSON.stringify({
                title: $('#board_title').val(),
                subTitle: $('#board_sub_title').val(),
                content: $('#board_content').val(),
                boardType: $('#board_type option:selected').val()
            });
            $.ajax({
                       url: "http://localhost:8081/api/boards",
                       type: "POST",
                       data: jsonData,
                       contentType: "application/json",
                       headers: {
                           "Authorization": "Basic " + btoa("havi" + ":" + "test")
                       },
                       dataType: "json",
                           success: function () {
                               alert('저장 성공!');
                               location.href = '/board/list';
                       },
                       error: function () {
                           alert('저장 실패!');
                       }
                   });
        });
    </script>
    <script th:if="${board?.idx}">
        $('#update').click(function () {
            var jsonData = JSON.stringify({
                title: $('#board_title').val(),
                subTitle: $('#board_sub_title').val(),
                content: $('#board_content').val(),
                boardType: $('#board_type option:selected').val(),
                createdDate: $('#board_create_date').val()
            });
            $.ajax({
                       url: "http://localhost:8081/api/boards/" + $('#board_idx').val(),
                       type: "PUT",
                       data: jsonData,
                       contentType: "application/json",
                       dataType: "json",
                       success: function () {
                           alert('수정 성공!');
                           location.href = '/board/list';
                       },
                       error: function () {
                           alert('수정 실패!');
                       }
                   });
        });
        $('#delete').click(function () {
            $.ajax({
                       url: "http://localhost:8081/api/boards/" + $('#board_idx').val(),
                       type: "DELETE",
                       success: function () {
                           alert('삭제 성공!');
                           location.href = '/board/list';
                       },
                       error: function () {
                           alert('삭제 실패!');
                       }
                   });
        });
    </script>
</body>
</html>
```
    
___
    
```html
        <input id="board_create_date" type="hidden" th:value="${board?.createdDate}"/>
```
기존 코드에서는 thymeleaf-extras-java8time 라이브러리를 사용하여 자바 8의 날짜값을 보기 편한 형식으로 변환했습니다.    
그리고 AJAX 통신에 사용하는 ```created_date``` 값을 hidden 타입의 input 필드로 추가했습니다.       
    
___    
    
```html   
 <script th:if="!${board?.idx}">
        $('#insert').click(function () {
            var jsonData = JSON.stringify({
                title: $('#board_title').val(),
                subTitle: $('#board_sub_title').val(),
                content: $('#board_content').val(),
                boardType: $('#board_type option:selected').val()
            });
            $.ajax({
                       url: "http://localhost:8081/api/boards",
                       type: "POST",
                       data: jsonData,
                       contentType: "application/json",
                       headers: {
                           "Authorization": "Basic " + btoa("havi" + ":" + "test")
                       },
                       dataType: "json",
                           success: function () {
                               alert('저장 성공!');
                               location.href = '/board/list';
                       },
                       error: function () {
                           alert('저장 실패!');
                       }
                   });
        });
    </script>
```   
board의 idx 값이 없으면 생성되지 않은 board를 추가합니다.   
따라서 저장을 위한 AJAX 코드만 포함되도록 설정했습니다.    
   
___
    
```html
<script th:if="${board?.idx}">
</script>
```
board 의 idx 값이 있으면 이미 생성된 board를 참조합니다.    
수정과 삭제가 가능한 스크립트가 포함되도록 설정했습니다.    
    
___   
    
```javascript
        $('#update').click(function () {
            var jsonData = JSON.stringify({
                title: $('#board_title').val(),
                subTitle: $('#board_sub_title').val(),
                content: $('#board_content').val(),
                boardType: $('#board_type option:selected').val(),
                createdDate: $('#board_create_date').val()
            });
            $.ajax({
                       url: "http://localhost:8081/api/boards/" + $('#board_idx').val(),
                       type: "PUT",
                       data: jsonData,
                       contentType: "application/json",
                       dataType: "json",
                       success: function () {
                           alert('수정 성공!');
                           location.href = '/board/list';
                       },
                       error: function () {
                           alert('수정 실패!');
                       }
                   });
        });
```
수정시에는 JSON 형식으로 데이터를 만들고     
```url: "http://localhost:8081/api/boards/" + $('#board_idx').val(),``` 에서 idx를 기준으로 
PUT 요청하여 해당 board 객체를 수정하도록 합니다.   
      
___   
       
```javascript
        $('#delete').click(function () {
            $.ajax({
                       url: "http://localhost:8081/api/boards/" + $('#board_idx').val(),
                       type: "DELETE",
                       success: function () {
                           alert('삭제 성공!');
                           location.href = '/board/list';
                       },
                       error: function () {
                           alert('삭제 실패!');
                       }
                   });
        });
```
삭제시에는 따로 데이터를 만들 필요 없이 idx 값을 기준으로 DELETE를 요청하여 데이터를 삭제합니다.   
   
___      
   
이전에 진행했던 웹 프로젝트는 H2db 를 사용하여 메모리에 데이터를 저장하고 가져왔습니다.      
이번에는 MySQL가 연동해서 REST API와 함께 사용하겠습니다.         
```build.gradle``` 파일에 MySQL 의존성을 추가해줍니다.   

```gradle
	runtime('mysql:mysql-connector-java')
```

**build.gradle**
```gradle
buildscript {
	ext{
		springBootVersion = '2.0.3.RELEASE'
	}
	repositories {
		mavenCentral()
		jcenter()
	}
	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
	}
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'

group = 'com.web'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = 1.8

repositories {
	mavenCentral()
	jcenter()
}

dependencies {
	compile('org.springframework.security:spring-security-oauth2-client')
	compile('org.springframework.security:spring-security-oauth2-jose')
	compile('org.springframework.boot:spring-boot-starter-security')
	compile('org.springframework.boot:spring-boot-starter-web')
	compile('org.springframework.boot:spring-boot-starter-thymeleaf')
	compile('org.springframework.boot:spring-boot-starter-data-jpa')
	runtime('com.h2database:h2')
	runtime('mysql:mysql-connector-java')
	runtime('org.springframework.boot:spring-boot-devtools')
	compileOnly('org.projectlombok:lombok')
	testCompile('org.springframework.boot:spring-boot-starter-test')
}

test {
	useJUnitPlatform()
}    
```
스프링 부트는 간단하게 MySQL을 연동시킬 수 있습니다.       
YAML 파일에 MySQL 관련 설정을 아래와 같이 추가합니다.     

```yml
spring:
  datasource:
     url: jdbc:mysql://127.0.0.1/{DB명}
     username: {아이디}    
     password: {패스워드}   
     driver-class-name: com.mysql.jdbc.Driver
```
```jpa.hibernate.ddl-auto``` 프로퍼티값을 create 두었습니다.       
이 옵션은 애플리케이션이 구동될 때마다 기존 테이블을 삭제하고 다시 생성합니다.          
   
**application.yml**
```yml
spring:
  #  datasource:
  #    url: jdbc:mysql://
  #    username:
  #    password:
  #    driver-class-name: com.mysql.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: create
  h2:
    console:
      enabled: true
  devtools:
    livereload:
      enabled: true
  thymeleaf:
    cache: false
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: 
            client-secret: 
          facebook:
            client-id: 
            client-secret: 
custom:
  oauth2:
    kakao:
      client-id: 
```     
필자 같은 경우는 h2 데이터베이스를 사용할 예정이므로 mysql 관련 내용을 주석처리했습니다.    
   
___  
        
REST API 프로젝트는 멀티 모듈로 구성하여             
MVC 패턴을 사용하는 방식은 rest-web 모듈로,               
스프링 부트 데이터 레스트 방식은 data-rest 모듈로 환경을 구성하겠습니다.          
성격이 같고 공통된 의존성이 존재하니 멀티 모듈로 구성하며 비교 분석합니다.        

**우선 기존 프로젝트 말고 새로운 프로젝트를 만들어 줍시다.**    
새로운 프로젝트명을 ```boot-rest``` 로 하여 기본 경로에 새로운 프로젝트를 생성합니다.         
    
생성 이후 멀티 모듈로 프로젝트를 구성하고 필요한 의존성을 주입하겠습니다.        
구성할 모듈은 MVC 패턴의 ```rest-web```과 데이터 레스트 방식의 ```data-rest```로 이름을 정하여 설정할겁니다.    
    
* 방법 :      https://github.com/kwj1270/TIL_FIRST_SPRINGBOOT2/blob/master/02%20%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%20%ED%99%98%EA%B2%BD%20%EC%84%A4%EC%A0%95.md#32-%EA%B7%B8%EB%A0%88%EC%9D%B4%EB%93%A4-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0             
        
**setting.gradle**	
```gradle
rootProject.name = 'boot-rest'

include 'data-rest'
include 'rest-web'
```

**build.gradle**
```gradle

buildscript {
    ext {
        springBootVersion = '2.0.3.RELEASE'
    }
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'eclipse'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'

    group = 'com.web'
    version = '0.0.1-SNAPSHOT'
    sourceCompatibility = 1.8

    repositories {
        mavenCentral()
    }

    dependencies {
        compile('org.springframework.boot:spring-boot-starter-data-jpa')
        compile('org.springframework.boot:spring-boot-starter-security')
        compile('com.fasterxml.jackson.datatype:jackson-datatype-jsr310')
        compile('org.springframework.data:spring-data-rest-hal-browser')

        runtime('org.springframework.boot:spring-boot-devtools')
        runtime('mysql:mysql-connector-java')
        runtime('com.h2database:h2')
        compileOnly('org.projectlombok:lombok')
        testCompile('org.springframework.boot:spring-boot-starter-test')
        testCompile('org.springframework.security:spring-security-test')
    }
}

project(':data-rest') {
    dependencies {
        compile('org.springframework.boot:spring-boot-starter-data-rest') {
            exclude module: "jackson-databind"
        }
    }
}

project(':rest-web') {
    dependencies {
        compile('org.springframework.boot:spring-boot-starter-web') {
            exclude module: "jackson-databind"
        }
        compile('org.springframework.boot:spring-boot-starter-hateoas')
    }
}
```
