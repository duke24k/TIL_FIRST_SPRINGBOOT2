
02 스프링부트 환경 설정
=======================

# 1. JDK 설치


***
# 2. 인텔리제이 IDEA 사용하기  
## 2.1. 커뮤니티 버전과 얼티미트 버전   
## 2.2. 커뮤니티 버전에서 스프링 부트 사용하기 
```java
package community.community;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@SpringBootApplication
public class CommunityApplication {

	public static void main(String[] args) {
		SpringApplication.run(CommunityApplication.class, args);
	}

	@GetMapping
	public String HelloWorld(){
		return "Hello World!";
	}
}
```
## 2.3. 얼티미트 버전에서 스프링 부트 사용하기    


***
# 3. 그레이들 설치 및 빌드하기   
**메이븐 설정 파일인 ```pom.xml```은 XML 기반으로 작성되어 있어서 동적인 행위에 제약이 있습니다.**                
그래서 대안으로 나온 그루비 기반의 그레들이 주목받고 있습니다.        
      
그레이들은 앤트로부터 기본적인 빌드 도구의 기능을, 메이븐으로 의존 라이브러리 관리 기능을 차용했습니다.              
멀티 프로젝트 구성 시에는 메이븐처럼 상속 구조가 아닌 설정 주입 방식을 사용하여 훨씬 유연하게 빌드 환경을 구성할 수 있습니다.       
      
## 3.1. 그레이들 래퍼    
그레이들 메인 홈페이지에 접속하여 각각의 OS 환경에 맞게 그레이들을 다운로드 설치합니다.   
   
https://gradle.org/install/
    
          
**그레이들 설정 관련 기본 구조**          
```
|---- gradle
|       ㄴ wrapper
|           |------- gradle-wrapper.jar      
|           ㄴ------ gradle-wrapper.properties   
|
|---- gradlew
|
|---- gradlew.bat
```
    
* gradlew : 리눅스 및 맥OS용 셸 스크립트        
* gradlew.bat : 윈도우용 배치 스크립트        
* gradle/wrapper/gradle-wrapper.jar : Wrapper JAR         
* gradle/wrapper/gradle-wrapper.properties : 그레이들 설정 정보 프로퍼티 파일(버전 정보 등)     
        
**참고로** 스프링 이니셜라이저로 프로젝트를 생성하면 해당 프로젝트에 그레이들이 자동으로 설치됩니다.               
왜냐하면 그레이들 래퍼 때문인데 위 그림의 구조는 그레이들 래퍼와 관련된 설정이며          
프로젝트 첫 설정 시 **그레이들 관련 빌드 설정을 자동으로 해주기 때문입니다.**         
따라서 그레이들 래퍼를 설치하여 깃과 같은 VCS에서 관리하면 공동 작업자들이 설치 및 버전 관리를 편리하게 할 수 있습니다.       
     
그레이들로 구성된 프로젝트를 새로운 그레이들 버전으로 변경할 수도 있습니다.      
```gradle-wrapper.properties```에서 distributionUrl 을 원하는 그레이들 버전으로 수정하면 됩니다.     
즉, 그레이들 버전을 업그레이드 하고 싶다면 그레이들 래퍼를 사용해서 간단하게 처리할 수 있습니다.      
         
맥OS 나 리눅스 사용자라면 gradlew 셸 스크립트를 실행하면 됩니다.      
```
$ ./gradlew wrapper --gradle-version 4.8.1
```    
만약 권한이 없다는 메시지가 출력 된다면 파일 권한을 바꾸면 됩니다.  
```
$ chmod 755 gradlew
```
그리고 그레이들 버전을 확인하고 싶다면 ```-v```를 이용해도 됩니다.   
```
$ ./gradlew -v
```
### 제가 공부하는 책에서는 ```그레이들 4.8.1``` 로 사용할 것입니다.    

## 3.2. 그레이들 멀티 프로젝트 구성하기       
그레이들 멀티 프로젝트를 활용하면 여러 프로젝트를 마치 하나의 프로젝트처럼 사용할 수 있습니다.(그럼 왜 사용해?)         
일반적으로 이 기능은 공통 코드를 하나의 프로젝트로 분리하고 이를 재사용할 때 운용합니다.(공통 코드를 따로 분리시키기 위해 사용)      

```
예를 들면 커뮤니티 서비스를 개발한다고 합시다.   
웹, API, 배치, 기타 프로젝트가 존재할 겁니다.   
네 프로젝트 모두에서 공통된 도메인이나 유틸리티를 사용할 겁니다.   
이를 멀티 프로젝트로 구성하여 한번에 처리 및 관리를 하기 위해서 사용을 하는 것입니다.
멀티 프로젝트로 구성하면 이러한 중복 코드를 제거할 수 있어 실수와 번거로움을 줄일 수 있습니다.

만약 멀티 프로젝트로 구성하지 않으면 도메인 칼럼이 추가되거나 변결되었을 때 모든 프로젝트를 일일이 수정해주어야 합니다.  
```
   
## 그럼 **도메인 관련 코드를 별도의 프로젝트로 분리하여 관리하는 멀티 프로젝트를 구성해보겠습니다.**     
### 3.2.1. ```setting.gradle``` 파일에 루트 프로젝트 추가 (```setting.gradle```파일은 그레이들 설정 파일입니다)  

**setting.gradle**
```gradle  
rootProject.name = 'demo'
```

### 3.2.1. 테스트로 사용할 ```demo-web``` 모듈과 공용으로 사용할 ```demo-domain``` 모듈을 생성
1. ```demo-web``` 모듈 생성  
      1. ```New -> Module```
      2. ```Gradle``` 선택한 뒤 ```Java``` 선택 후 Next
      3. ```Add as module to``` 에서 community 프로젝트를 선택한 다음,
      4. ```ArtifactId``` 에 ```demo-web``` 을 입력하고 Next 눌러 모듈 생성   
      5. 생성된 ```demo-web``` 모듈에는 ```build.gradle``` 파일만 존재한다.  
      6. 아래와 같이 기본 패키지 경로 (디렉토리)를 만들어주자       
      * ```src/main/java/com/demo``` : 자바 소스 디렉토리  
      * ```src/test/java/com/demo``` : 스프링 부트 테스트 코드 디렉토리 
      * ```src/main/resources/static``` : static한 파일(css,image,js)의 디폴트 경로    
      * ```src/main/resources/templates``` : thymeleaf, freemarker 및 기타 서버 사이드 템플릿 파일의 경로     
         
그리고 이렇게 Module 을 생성하면 루트 프로젝트의 ```setting.gradle```에 생성된 모듈명이 인클루드 됩니다.     
```
rootProject.name = 'demo'
include 'demo-web'
```
    
2. ```demo-web``` 과 같은 방식으로 ```demo-domain``` 모듈도 생성합니다.   
      1. ```New -> Module```
      2. ```Gradle``` 선택한 뒤 ```Java``` 선택 후 Next
      3. ```Add as module to``` 에서 community 프로젝트를 선택한 다음,
      4. ```ArtifactId``` 에 ```demo-domain``` 을 입력하고 Next 눌러 모듈 생성   
      5. 생성된 ```demo-domain``` 모듈에는 ```build.gradle``` 파일만 존재한다.  
      6. 아래와 같이 기본 패키지 경로 (디렉토리)를 만들어주자       
      * ```src/main/java/com/demo``` : 자바 소스 디렉토리  
      * ```src/test/java/com/demo``` : 스프링 부트 테스트 코드 디렉토리 
       
```demo-domain```은 리소스 파일을 갖고 있지 않기 때문에 리소스 패키지를 따로 생성하지 않았습니다.      
    
동일한 방식으로 다양한 멀티 프로젝트를 더 많이 구성할 수 있습니다.   
멀티프로젝트를 구성하면 코드 재사용이 높아지고 한 서비스에 관련된 여러 프로젝트를 마치 하나의 통합 프로젝트처럼 관리할 수 있습니다.  
     

***
# 4. 환경 프로퍼티 파일 설정하기   
스프링 부트 프로퍼티 파일은 설정 관련 및 기타 정적인 값을 키값 형식으로 관리합니다.       
이 파일을 사용하면 기존 스프링 프레임워크의 복잡한 XML 설정을 파일 하나로 대체할 수 있습니다.   
   
**예시**      
```
server.port: 80   
```
   
기존에는 Properties 파일을 많이 사용했지만 **최근에는 표현의 한계로 YAML 파일을 더 많이 사용합니다.**   
```src/main/resources/application.yml```을 생성하고 다음과 같이 변경합니다.   

**application.yml**
```yml
server:
      port: 80
```
프로퍼티 설정값의 깊이에 따라 들여쓰기를 해서 걔층 구조를 훨씬 쉽게 파악할 수 있습니다.   
      
YAML을 설정하려면 SnakeYAML 라이브러리를 포함해야 하지만 스프링 부트 스타터에 기본적으로 내장되어 있다.    
즉, 스프링 부트 스타터를 사용하면 별도의 설정 없이 사용할 수 있다.       
그리고 ```application.properties``` 와 ```application.yml```이 동시에 존재하면 ```.yml``` 파일만 실행된다.       
그래도 ```.yml``` 파일로만 작업을 할 것이니 ```src/main/resources/applicaion.properties```는 삭제해주자      
   
```
원래 YAML은 'YAML은 마크업 언어가 아니다 - YAML Ain't Markup Language' 라는 뜻으로   
핵심이 문서 마크업이 아닌 데이터 중심에 있다는 것을 보여줍니다.   
그에 맞게 가독성이 좋으며 문법이 이해하기 수월하도록 작성된 언어입니다.   
```

## 4.1. 프로파일에 따른 환경 구성 분리   
실제 서비스에서는 로컬 DB, 개발 DB, 운영 DB의 설정값이 모두 다릅니다.   
이런 경우를 대비해 프로파일에 따라 프로퍼티를 다르게 설정해야 합니다.   
   
**YAML** 파일에서 프로퍼티 설정을 구분하는 방법은 간단합니다.   
다음과 같이 ```---``` 을 기준으로 설정값을 나눕니다.   
    
**application.yml**
```yml   
server:
  port: 80
---
spring: 
  profiles: local
server:
  port: 8080
---
spring:
  profiles: dev
server:
  port: 8081
---
spring:
  profiles: real
server:
  port: 8082
---
```
최상단에 ```server.port``` 프로퍼티값을 80으로 설정한 부분은 프로파일과는 상관없이 디폴트로 정의되는 영역입니다.       
**또다른 방법으로 ```application-[profile].yml```을 이용하는 겁니다.**                    
     
```[profile]```에 원하는 프로파일 값으로 YAML 파일을 추가하면             
애플리케이션 실행 시 ```application-[profile].yml```에서 지정한 프로파일값을 바탕으로 실행됩니다.          
즉, **호출한 ```yml```이 우선순위가 되고 이외에 존재하는 프로퍼티들도 ```applcaiton.yml```순서에 따라 설정됩니다.**            
   
### 이번에는 프로파일값을 적용하여 애플리케이션을 실행하는 방법을 알아보겠습니다.   
```local```, ```dev```, ```real```과 같이 각각의 프로파일값을 따로 지정하여 애플리케이션을 실행한다 가정합니다.   
스프링 부트 프로젝트는 JAR 파일로 빌드하기에 서버에서 직접 간단한 명렬으로 실행할 수 있습니다.    
   
아래 와 같이 실행하여 프로파일 값을 활성화할 수 있습니다.

```
$ java -jar -D spring.profiles.active=dev
```
```
java -Dspring.profiles.active=dev -jar [jar파일명].jar
java -jar [jar파일명].jar --spring.profiles.active=dev
```
출처: https://freestrokes.tistory.com/106 [FREESTROKES DEVLOG]     
      
      
인텔리제이는 스프링 부트 실행 플러그인을 따로 사용하기 때문에       
```Edit Configurations``` 버튼을 눌러 ```Run/Debug configurations``` 창을 실행하고     
스프링 부트 플러그인의 프로파일 값을 할당하면 됩니다.      

**얼티메이트와 커뮤니티는 Application 타입이 달라서 환경이 다르다**    
커뮤니티를 기준으로 ```VM options:```에 ```-Dspring.profiles.active=dev```로 설정해주면된다.   
   
[사진]   
    

## 4.2. YAML 파일 매핑하기  
YAML 파일을 사용하면 깊이에 따라 관계를 구분 짓기 때문에      
```List```, ```Set```, ```Map``` 등 다양한 바인딩형 매핑이 훨씬 편합니다.     
      
YAML 파일에 있는 데이터를 가져와서 사용하는 방법은 다양합니다. (properties의 매핑 방법도 같습니다.)          
유용하게 사용되는 ```@Value```와 ```@ConfigurationProperties``` 어노테이션을 비교해보겠습니다.      

```
어노테이션이란 클래스, 메소드, 필드 등 프로그램 요소에 정보를 제공하는 기법입니다.   
타깃 요소를 제어/관리/명시하는 등의 다양한 기능을 할 수 있습니다.   
```

[사진]  

각 기능은 다음과 같습니다.  
   
* **유연한 바인딩 :**   
프로퍼티값을 객체에 바인딩할 경우 필드를 낙타표기법(aBc)으로 선언하고        
프로퍼티의 키는 다양한 형식(낙타, 케밥, 스네이크)으로 선언하여 바인딩할 수 있습니다.      
      
* **메타데이터 지원  :**     
프로퍼티의 키에 대한 정보를 메타데이터 파일로 제공합니다.                     
키의 이름, 타입, 설명, 디폴트값 등 키 사용에 앞서 힌트가 되는 정보를 얻을 수 있습니다.                    
       
* **SpEL(Spring Expression Language, 스프링 표현언어) 평가 :**          
SpEL은 런타임에 객체 참조에 대해 질의하고 조작하는 기능을 지원하는 언어입니다.              
특히 메소드 호출 및 기본 문자열 템플릿 기능을 제공합니다.          
```@Value```만 사용 가능합니다.              
   
표만 봐서 감이 잡히지 않을 것이니 코드를 보면서 이해해보도록 하겠습니다.    
         
## 4.3. ```@Value``` 살펴보기   
**프로퍼티의 키를 사용하여 특정한 값을 호출할 수 있습니다.**      
키를 정확히 입력해야 하며 값이 없을 겨웅에 대해 예외 처리를 해주어야 합니다.    
    
```application.yml``` 파일에 아래와 같은 소스코드를 입력해줍니다.              
그리고 테스트 프로퍼티값을 매핑해서 사용하는 ```AutoConfigurationApplicationtests``` 클래스를 생성하겠습니다.        

1. ```application.yml``` 에 아래 소스코드 입력         
```yml
property:
  test:
    name: property depth test
propertyTest: test
propertyTestList: a,b,c
``` 
    
**application.yml**
```yml
server:
  port: 80
---
spring:
  profiles: local
server:
  port: 8080
---
spring:
  profiles: dev
server:
  port: 8081
---
spring:
  profiles: real
server:
  port: 8082
---
property:
  test:
    name: property depth test
propertyTest: test
propertyTestList: a,b,c
```
2. ```src``` -> ```test``` -> ```java``` -> ```com``` -> ```demo``` 에 ```AutoConfigurationApplicationtests``` 클래스를 생성         
3. 아래와 같은 코드를 입력   
4. 메소드 옆에 run 화살표를 눌러서 실행해준다.   

**AutoConfigurationApplicationtests**     
```java
package com.springboot.springboot;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import static org.hamcrest.Matchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = {com.springboot.springboot.AutoConfigurationApplicationTests.class})
public class AutoConfigurationApplicationTests {

        @Value("${property.test.name}")
        private String propertyTestName;

        @Value("${propertyTest}")
        private String propertyTest;

        @Value("${noKey:default value}")
        private String defaultValue;


        @Value("${propertyTestList}")
        private String [] propertyTestArray;

        @Value("#{'${propertyTestList}'.split(',')}")
        private List<String> propertyTestList;

    @Test
    public void contextLoads(){
        assertThat(propertyTestName, is("property depth test"));

        assertThat(propertyTest, is("test"));
        assertThat(defaultValue, is("default value"));

        assertThat(propertyTestArray[0], is("a"));
        assertThat(propertyTestArray[1], is("b"));
        assertThat(propertyTestArray[2], is("c"));

        assertThat(propertyTestList.get(0), is("a"));
        assertThat(propertyTestList.get(1), is("b"));
        assertThat(propertyTestList.get(2), is("c"));

    }

}
```
책에서는 단순히 ```@SpringBootTest```로 되어있지만        
최근에는 ```@SpringBootTest(classes = {com.springboot.springboot.AutoConfigurationApplicationTests.class})```로 바뀐 것 같다.        
       
```assertThat()```과 ```is()```는 ```import static```으로 받은 클래스의 메소드이다.       
그렇기에 ```ctrl + space``` 추가하기는 어렵고 직접 import 에 타이핑을 해주어야 한다.       
참고로 메소드가 아닌 중간의 클래스 이름만 치고 ```ctrl + space```로 추가하면 클래스의 패키지는 알아서 붙고 메소드만 입력해주면된다.      

```asserThat()```의 첫번째 파라미터와 두번째 파라미터가 일치해야 테스트가 성공한다.        

만약 에러가 아니라 테스트가 Run 자체가 실행이 안된다면          
```IntelliJ IDEA``` 클릭 -> ```Preferences``` ->  ```Build, Execution, Deployment``` -> ``` run test using```을 ```intelliJ IDEA``` 로 바꾸면된다.      
필자 같은 경우 테스트 Run 자체 에러가 나서 ```intelliJ IDEA```로 바꾸었다.         
___
```@Value``` 매핑 방식은 다음과 같다.   
* ```@Value("${property.test.name}")``` : 깊이가 존재하는 키 값에 대해 ```.``` 로 구분하여 값을 매핑한다.   
* ```@Value("${propertyTest}")``` : 단일 키값을 매핑한다.   
* ```@Value("${noKey:default value}")``` : YAML 파일에 키값이 존재하지 않으면 디폴트값이 매핑되도록 설정합니다.    
* ```@Value("${propertyTestList}")``` : 여러값을 나열할 때는 배열형으로 매핑합니다 ```(단순 키로 찾지만 값이 여러개면 배열 형태로 받음)```
* ```@Value("#{'${propertyTestList}'.split(',')}")``` : SpEL을 사용하여 ```,``` 기준으로 List에 매핑한다.   
       
```@Value```에서 유일하게 지원되는 기능인 SpEL을 사용하여 매핑하는 방법을 알아봤습니다.       
간단하게 설명하자면 YAML 파일에서 설정한 키값을 ```@Value```의 프로퍼티 값으로 주면 해당 값이 필드값에 할당되는 방식입니다.          
주로 단일 필드갑을 가져오는데 사용합니다.       

## 4.4. ```@ConfigurationProperties``` 살펴보기    
```@ConfigurationProperties```의 프로퍼티를 사용하여 다양한 형의 프로퍼티값을 매핑할 수 있습니다.       
```@ConfigurationProperties```는 기본적으로 접두사를 사용하여 값을 바인딩합니다.       
아래와 같이 ```fruit```를 키값으로 하여 리스트형의 테스트 데이터를 지정합니다.         
여기서 ```fruit```는 접두사이자 기본 키값이 됩니다.        

```yml
fruit:
  list:
    - name: banana
      color: yellow
    - name: apple
      color: red
    - name: water melon
      color: green
```
우선 ```application.yml```에 위 코드를 추가합니다.         
             
**전체 application.yml**   
```yml  
server:
  port: 80
---
spring:
  profiles: local
server:
  port: 8080
---
spring:
  profiles: dev
server:
  port: 8081
---
spring:
  profiles: real
server:
  port: 8082
---
property:
  test:
    name: property depth test
propertyTest: test
propertyTestList: a,b,c

fruit:
  list:
    - name: banana
      color: yellow
    - name: apple
      color: red
    - name: water melon
      color: green
```   
        
이제 원하는 대로 객체에 바인딩 되는지 테스트를 하기위한 클래스를 생성해줍시다.       
```main``` -> ```java``` -> ```pojo``` 디렉토리 만들고 ```FruitProperty``` 클래스를 생성합니다.          
      
**FruitProperty**      
```java  
package com.demo.pojo;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Data
@Component
@ConfigurationProperties("fruit")
public class FruitProperty {
    private List<Map> list;
}
```  
      
원하는 형을 선택하여 ```@Value```보다 더 객체 지향적으로 프로퍼티를 매핑할 수 있습니다.              
이제 ```application.yml```의 프로퍼티값들은 ```@ConfigurationProperties```를 활용한           
```FruitProperty``` 클래스의 리스트 필드로 바인딩입니다.           
        
```@ConfigurationProperties``` 어노테이션을 사용하려면 클래스를 ```@Component```로 선언을 해야합니다.        
그래야 이 클래스를 사용할 곳에서 의존성주입을 할 수 있기 때문입니다.          
여기서는 접두사가 ```fruit```인 프로퍼티가 값을 읽어 와서 필드값에 매핑한다.         
     
```application.yml``` 에 한번에 기술하는 것이 아닌 
```application-[profiles].yml``` 처럼 파일로 따로 관리할 경우 아래와 같은 코드로 기술해야 한다.         
```java   
@ConfigurationProperties(prefix = "fruit")
```      
     
그리고 ```@Data```는 롬복 코드로서 롬복 플러그인과 라이브러리를 의존성으로 내려받아야 사용할 수 있다.       
이를 위해서 책에 뒷부분에 있는 부록 설명을 보던가      
https://github.com/kwj1270/TIL_SPRINGBOOT_WITH_AWS/blob/master/02%20%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%97%90%EC%84%9C%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0.md     
의 롬복 관련 내용을 봐서 설치하면 될 것 같다.     
   
이제 생성한 코드가 제대로 동작하는지 ```FruitProperty```를 의존성으로 추가하는 ```PropertyTest```클래스 생성해 테스트해보겠습니다.      
       
**책에서 나온 코드**
```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class PropertyTest {
```
책에서 나온 코드로는 돌아가지 않는다.   
1. ```@Component``` 로 올린 객체를 스캔하지 못한다.        
2. ```@ConfigurationProperties("fruit")``` 로 설정한 객체를 활성화 시키지 않았다.   

1번의 이유는 **프로젝트가 여러 모듈로 나눠서 사용하기에 클래스가 겹칠 수 있으니 어디서 스캔할 것인지를 정확히 명시해줘야 한다**                
2번의 이유는 사용하는 곳에서 ```@ConfigurationProperties("fruit")```가 쓰여진 클래스를 활성화 시켜주고 사용해야한다.          
거기다가 2번도 프로젝트가 여러 모듈로 나뉘니 정확한 범위의 클래스를 입력해주는 것이 좋다.         

**수정한 코드**
```java
@RunWith(SpringRunner.class)
@ComponentScan({"com.demo.pojo"})
@EnableConfigurationProperties(com.demo.pojo.FruitProperty.class)
@SpringBootTest(classes = {com.demo.pojo.PropertyTest.class})
public class PropertyTest {
```

1. ```test``` -> ```java``` -> ```com``` -> ```demo``` -> ```pojo``` 에서 PropertyTest 클래스 생성   
2. 아래와 같은 코드 입력 

**PropertyTest**    
```java
package com.demo.pojo;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;
import java.util.Map;

import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

@RunWith(SpringRunner.class)
@ComponentScan({"com.demo.pojo"})
@EnableConfigurationProperties(com.demo.pojo.FruitProperty.class)
@SpringBootTest(classes = {com.demo.pojo.PropertyTest.class})
public class PropertyTest {

    @Autowired
    FruitProperty fruitProperty;

    @Test
    public void test(){
        List<Map> fruitData = fruitProperty.getList();

        assertThat(fruitData.get(0).get("name"), is("banana"));
        assertThat(fruitData.get(0).get("color"), is("yellow"));

        assertThat(fruitData.get(1).get("name"), is("apple"));
        assertThat(fruitData.get(1).get("color"), is("red"));

        assertThat(fruitData.get(2).get("name"), is("water melon"));
        assertThat(fruitData.get(2).get("color"), is("green"));

        /*
        System.out.println(fruitData.get(0).get("name"));
        System.out.println(fruitData.get(0).get("color"));

        System.out.println(fruitData.get(1).get("name"));
        System.out.println(fruitData.get(1).get("color"));

        System.out.println(fruitData.get(2).get("name"));
        System.out.println(fruitData.get(2).get("color"));
        
        */
    }
}
```
### 4.4.1. ```@ConfigurationProperties``` 살펴보기 - POJO 방식      
```@ConfigurationProperties```는 기본 컬렉션 타입뿐만 아니라 POJO(Plain Old Java Object) 타입 매핑도 지원합니다.    
기존 ```List<Map> list;``` 방식보다는 ```List<Fruit(POJO)> list``` 이런식으로 사용하는 것이 **직관적이고 명확하게 객체를 구성할 수 있습니다.**      
    
먼저 Fruit POJO 클래스를 생성해줍시다.     

1. ```main``` -> ```java``` -> ```com``` -> ```demo``` -> ```pojo``` 에서 Fruit 클래스 생성  
2. 아래와 같은 코드 입력   

**Fruit**
```java
package com.demo.pojo;

import lombok.Data;

@Data
public class Fruit {
    private String name;
    private String color;
}
```
```Fruit``` 클래스를 생성했다면 ```FruitProperty``` 클래스에서 기존의 ```Map``` 타입을 앞서 생성한 ```Fruit``` 타입으로 변경합니다.
  
**FruitProperty**
```java
package com.demo.pojo;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;

@Data
@Component
@ConfigurationProperties("fruit")
public class FruitProperty {
    private List<Fruit> list;
}
```
```PropertyTest``` 클래스에서 ```Map``` 의 ```get()``` 메소드가 아닌        
```Fruit```의 객체 메서드(getter)를 사용하여 name 과 color 값을 읽어올 수 있습니다.         
    
**PropertTest**
```java
package com.demo.pojo;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;
import java.util.Map;

import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

@RunWith(SpringRunner.class)
@ComponentScan({"com.demo.pojo"})
@EnableConfigurationProperties(com.demo.pojo.FruitProperty.class)
@SpringBootTest(classes = {com.demo.pojo.PropertyTest.class})
public class PropertyTest {

    @Autowired
    FruitProperty fruitProperty;

    @Test
    public void test(){
        List<Fruit> fruitData = fruitProperty.getList();

        assertThat(fruitData.get(0).getName(), is("banana"));
        assertThat(fruitData.get(0).getColor(), is("yellow"));

        assertThat(fruitData.get(1).getName(), is("apple"));
        assertThat(fruitData.get(1).getColor(), is("red"));

        assertThat(fruitData.get(2).getName(), is("water melon"));
        assertThat(fruitData.get(2).getColor(), is("green"));

        /*
        System.out.println(fruitData.get(0).get("name"));
        System.out.println(fruitData.get(0).get("color"));

        System.out.println(fruitData.get(1).get("name"));
        System.out.println(fruitData.get(1).get("color"));

        System.out.println(fruitData.get(2).get("name"));
        System.out.println(fruitData.get(2).get("color"));

        */
    }
}
```    
이제 똑같이 Run을 시켜줘서 문제가 없으면 성공인 것입니다.    

## 4.5. ```@ConfigurationProperties``` 의 유연한 바인딩   
```@ConfigurationProperties``` 에서 유연한 바인딩이란    
프로퍼티값을 객체에 바인딩할 경우 필드를 낙타 표기법으로 선언하고    
프로퍼티의 키는 다양한 형식으로 선언하여 바인딩할 수 있는 것을 말합니다.   
      
**예시 코드 - 작성x**
```java
@Data
@Component
@ConfigurationProperties("fruit")
public class FruitProperty {
    private String colorName;
}
```
```colorName``` 필드를 선언했습니다.     
이제 프로퍼티명을 지어서 필드에 바인딩해보겠습니다.       
놀랍게도 다음과 같이 다양한 프로퍼티명이 모두 colorName 필드에 바인딩 될 수 있습니다.         
   
* fruit.color-name    
* fruit.color_name    
* fruit.colorName    
* fruit.Colorname     
      
```
기존 버전에서는 
```
