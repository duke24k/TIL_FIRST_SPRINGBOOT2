04 스프링 부트 웹
=======================
스프링 부트 웹 ```(spring-boot-web)``` 을 이용하여 커뮤니티 게시판을 만들어보겠습니다.    
스프링 부트 웹 ```(spring-boot-web)```은 주로 view 페이지나 API 서비스의 구현에 사용됩니다.   
  
스프링 부트 웹을 구성하는 방법은 매우 다양합니다.           
그러므로 상황에 맞는 패턴과 코드를 사용해야 합니다.                  
   
모든 방식을 담을 수는 없으니 스프링에서 제공하는 편리한 라이브러리를 어떻게 사용하는지 살펴볼겁니다.   

# 1. 커뮤니티 게시판 설계하기    

아래 그림은 전형적인 MVC 패턴으로      
사용자의 요청에 대한 데이터 처리 흐름이 애플리케이션 내부에서 어떻게 동작하는지 확인하기 위한 그림입니다.        
   
[사진]   
  
클라이언트가 서버에 데이터를 요청하면 서버가 데이터를 제공합니다.     
데이터를 요청 받은 서버는 타임리프(서버 사이드 템플릿 엔진)를 사용하여 뷰를 멋있게 구성하여 보여줍니다.      

```
타임리프 : 웹 또는 독립적인 실행 환경에서 사용되는 자바 서버 사이드 템플릿 엔진입니다.   
          세계적을 많이 쓰이고 있으며 스프링 부트에서도 공식적인 템플릿 엔진이며 스타터를 지원하고 있습니다. 
```

[사진]
  
우리는 간단한 CRUD 기능만 제공하는 게시판을 구현하겠습니다.     
   
[사진]   
   
어떤 기능을 구성할지 설계했으니 이제는 게시판을 구성하는 객체들을 명확히 정할 수 있습니다.     
필요한 게시판의 객체는 Board 와 User 입니다.         
이 두 도메인의 관계를 표현하면 위 그림과 같습니다.         
    
추가적으로 PK 는 두 테이블 모두 인덱스값으로 설정했고 글(Board)에서는 회원(User) 인덱스를 참조하여 ```1:1``` 관계로 설정했습니다.      
    
***  
# 2. 커뮤니티 게시판 프로젝트 준비하기   
인텔리제이를 사용하여 프로젝트를 생성합시다.       
    
https://github.com/kwj1270/TIL_FIRST_SPRINGBOOT2/blob/master/02%20%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%20%ED%99%98%EA%B2%BD%20%EC%84%A4%EC%A0%95.md   
   
위 주소를 참조하여 생성도록 합시다.      
**프로젝트 명은 : ```Spring-Boot-Community-Web```으로 하겠습니다.**            
   
<img width="1440" alt="스크린샷 2020-06-28 오후 3 13 00" src="https://user-images.githubusercontent.com/50267433/85939681-83ec9c00-b952-11ea-8ed5-18832eccfe33.png">
      
인텔리제이를 사용하여 프로젝트 의존 라이브러리를 생성하는 방식과              
스프링 이니셜라이저를 사용하여 의존 라이브러리를 구성하는 방식이 있습니다.       
        
```Web```, ```Thymeleaf```, ```JPA```, ```Devtools```, ```Lombok```, ```H2``` 라이브러리를 선택하여 프로젝트를 생성합니다.    
    
*** 
# 3. 커뮤니티 게시판 구현하기   
    
**개발 순서**   
   
1. 프로젝트 의존성 구성      
2. 스프링 부트 웹 스타터 살펴보기   
3. 도메인 매핑하기   
4. 도메인 테스트하기   
5. ```CommandLineRunner```를 사용하여 DB에 데이터 넣기   
6. 게시글 리스트 기능 만들기  
7. 타임리프 자바 8 날짜 포맷 라이브러리 추가하기 
8. 페이징 처리하기  
9. 작성 폼 만들기

## 3.1. 프로젝트 의존성 구성    
정상적으로 프로젝트를 구성했다면 루트 경로에 ```build.gradle```이 생성되었을겁니다.   
의존성을 다음과 같이 구성하겠습니다.    

**build.gradle**     
```gradle     
buildscript {
    ext{
        springBootVersion = '2.0.3.RELEASE'
    }
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'

group = 'com.web'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = 1.8

repositories {
    mavenCentral()
    jcenter()
}

dependencies {
    compile('org.springframework.boot:spring-boot-starter-web')
    compile('org.springframework.boot:spring-boot-starter-thymeleaf')
    compile('org.springframework.boot:spring-boot-starter-data-jpa')
    runtime('com.h2database:h2')
    runtime('org.springframework.boot:spring-boot-devtools')
    compileOnly('org.projectlombok:lombok')
    testCompile('org.springframework.boot:spring-boot-starter-test')
}

test {
    useJUnitPlatform()
}    
```   
```gradle
buildscript {
    ext{
        springBootVersion = '2.0.3.RELEASE'
    }
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}
```
```buildscript {}``` 빌드 스크립트 내부에 버전, 의존 라이브러리, 저장소를 설정해 스프링 부트 플러그인을 사용할 수 있게 합니다.       
```ext{}```, ```repositories{}```, ```dependencies{}``` 코드는 필요한 플러그인을 적용합니다.         
          
```gradle
apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'
```
종속성 관리를 제공하는 플러그인입니다.    
스프링 부트 ```1.x``` 버전에서는 기본으로 제공했지만 스프링 부트 ```2.0``` 이상에서는 플러그인 등록을 명시해주어야 합니다.      

```gradle
dependencies {
    compile('org.springframework.boot:spring-boot-starter-web')
    compile('org.springframework.boot:spring-boot-starter-thymeleaf')
    compile('org.springframework.boot:spring-boot-starter-data-jpa')
    runtime('com.h2database:h2')
    runtime('org.springframework.boot:spring-boot-devtools')
    compileOnly('org.projectlombok:lombok')
    testCompile('org.springframework.boot:spring-boot-starter-test')
}
```
프로젝트 내에 사용할 라이브러리의 의존성을 설정합니다.      
메인 부트 버전인 ```2.0.3``` 에 맞는 호환성을 가져오기 위해 디폴트 버전 사용하니다. (버전 명시도 가능하다는 말)     
   
```gradle
    runtime('com.h2database:h2')
    runtime('org.springframework.boot:spring-boot-devtools')
```
런타임 시점에만 H2 사용하도록 설정합니다.   
   
```gradle
    compileOnly('org.projectlombok:lombok')
```
```compileOnly()```는 컴파일 전용 종속성 선언 설정입니다.          
기존의 provided와 유사합니다.           
주로 컴파일 시점에만 필요하고 런타임 시점에는 필요 없을 때 많이 사용합니다.      
       
## 3.2. 스프링 부트 웹 스타터 살펴보기   
스프링 부트 웹은 웹 구성에 필요한 기본적인 요소를 담고 있습니다.   
   
밑에 코드는 스프링 부트 웹 스타터의 의존 관계 설정입니다.     
    
**스프링 부트 웹 스타터 의존 설정**    
```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>      
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-validator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-json</artifactId>
        </dependency>
       <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
        </dependency>
       <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
        </dependency>
    </dependencies>
```
* ```spring-boot-starter``` : 스프링 부트를 시작하는 기본적인 설정이 담겨 있는 스타터입니다.   
* ```spring-boot-starter-tomcat``` : 내장 톰켓을 사용하기 위한 스타터입니다.      
* ```hibernate-validator``` : 어노테이션 기반의 표준화된 제약 조건 및 유효성 검사 규칙을 표현하는 라이브러리입니다.       
* ```spring-boot-starter-json``` : jackson 라이브러리를 지원해주는 스타터입니다. JSON 데이터형의 파싱, 데이터 바인딩 함수등을 제공합니다.        
* ```spring-web``` : HTTP intergration, Servlet filters, Spring HTTP invoker 및 HTTP 코어를 포함시킨 라이브러리입니다.         
* ```spring-webmvc``` : request를 전달하는 MVC로 디자인된 DispatcherServlet 기반의 라이브러리입니다.    
    
## 3.3. 도메인 매핑하기   
이제 뷰에 데이터를 바인딩하여 반환하는 흐름을 알아보도록 하겠습니다.       
         
도메인 매핑은 JPA를 사용하여 **DB와 도메인 클래스를 연결시켜주는 작업입니다.**                    
도메인 클래스를 생성하여 H2 DB에 매핑해보겠습니다.                  
         
DB에서 (도메인을 활용하여) 레포지토리까지의 데이터 처리 흐름은 다음 그림과 같습니다.             
         
[사진]      
     
web 디렉토리 하위에 있는 domain 패키지에 설계한 Board 와 User 도메인의 클래스를 생성하겠습니다.      

1. ```main.java.com.web.domain.enums``` 에 ```BoardType``` enum 생성
2. 아래 코드 입력

**BoardType-enum**   
```java  
package com.web.domain.enums;

public enum BoardType {
    notice("공지사항"),
    free("자유게시판");
    
    private String value;
    
    BoardType(String value){
        this.value = value;
    }
    public String getValue(){
        return value;
    }
}
```
   
1. ```main.java.com.web.domain``` 에 ```Board``` 클래스 생성
2. 아래 코드 입력

**Board**
```java
package com.web.domain;

import com.web.domain.enums.BoardType;

import java.io.Serializable;
import java.time.LocalDateTime;

import javax.persistence.*;

import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;


@Getter
@NoArgsConstructor
@Entity
@Table
public class Board implements Serializable {

    @Id
    @Column
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idx;

    @Column
    private String title;

    @Column
    private String subTitle;

    @Column
    private String content;

    @Column
    @Enumerated(EnumType.STRING)
    private BoardType boardType;

    @Column
    private LocalDateTime createdDate;

    @Column
    private LocalDateTime updatedDate;

    @OneToOne(fetch = FetchType.LAZY)
    private User user;

    @Builder
    public Board(String title, String subTitle, String content, BoardType boardType, LocalDateTime createdDate, LocalDateTime updatedDate, User user) {
        this.title = title;
        this.subTitle = subTitle;
        this.content = content;
        this.boardType = boardType;
        this.createdDate = createdDate;
        this.updatedDate = updatedDate;
        this.user = user;
    }
}
```
mac os 같은 경우 ```cmd+n```을 누르면 ```[Generate]```가 뜨는데 생성자를 쉽게 만들 수 있게 해준다.     
```java
    @Id
    @Column
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idx;
```
```@GeneratedValue(strategy = GenerationType.IDENTITY)``` : 기본 키가 자동으로 할당되도록 설정하는 어노테이션       
기본키 할당 전략을 선택할 수 있는데, 키 생성을 데이터베이스에 위임하는 ```IDENTITY``` 전략을 사용했습니다.       
```
스프링 부트 1.x는 기본 키 할당 전략이 IDENTITY지만 2.x 부터는 TABLE로 변경되었습니다.    
따라서 명확히 IDENTITY로 명시하여 사용하지 않으면 한 테이블에서만 시퀀스가 관리되는 현상이 발생하게 됩니다.   
```
    
```java
    @Column
    @Enumerated(EnumType.STRING)
    private BoardType boardType;
```
```@Enumerated(EnumType.STRING)``` : Enum 타입 매핑용 어노테이션,           
```@Enumerated``` 어노테이션을 이용해 자바 ```enum```형과 데이터베이스 데이터 변환을 지원합니다.               
실제로 자바 enum 형이지만 데이터베이스의 ```String```형으로 변환하여 저장하겠다고 선언한 겁니다.        
     
```java
    @OneToOne(fetch = FetchType.LAZY)
    private User user;
```
```@OneToOne(fetch = FetchType.LAZY)``` :   
도메인 ```Board``` 와 ```Board```가 필드값으로 갖고 있는 ```User``` 도메인을 ```1:1``` 관계로 설정하는 어노테이션         
실제로 DB에 저장될 때는 ```User``` 객체가 저장되는 것이 아니라 ```User``` 의 PK인 ```user_idx``` 값이 저장됩니다.          
```fetch``` 는 ```eager``` 와 ```lazy``` 두 종류가 있는데       
```eager```는 처음 ```Board``` 도메인을 **조회할 때 즉시 관련 ```User``` 객체를 함께 조회**한다는 뜻이고.     
```lazy```는 ```User``` 객체를 조회하는 시점이 아닌 객체가 **실제 사용될 때 조회**한다는 뜻입니다.           
___

1. ```main.java.com.web.domain``` 에 ```User``` 클래스 생성
2. 아래 코드 입력    
       
**User**
```java
package com.web.domain;

import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.io.Serializable;
import java.time.LocalDateTime;

@Getter
@NoArgsConstructor
@Entity
@Table
public class User implements Serializable {

    @Id
    @Column
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idx;

    @Column
    private String name;

    @Column
    private String password;

    @Column
    private String email;

    @Column
    private LocalDateTime createdDate;

    @Column
    private LocalDateTime updateDate;

    @Builder
    public User(String name, String password, String email, LocalDateTime createdDate, LocalDateTime updateDate) {
        this.name = name;
        this.password = password;
        this.email = email;
        this.createdDate = createdDate;
        this.updateDate = updateDate;
    }
}
```
```java
    @Column
    private LocalDateTime createdDate;
    
    @Column
    private LocalDateTime updateDate;
```
```LocalDateTime```은 자바 8에 새로 추가된 기능입니다.          
기존에는 ```Date```, ```Calendar``` 등을 주로 사용했지만 날짜 연산 기능이 많이 부족했습니다.              
그래서 종전에는 날짜에 대한 연산, 비교 등을 API로 제공하는 ```JodaDateTime``` 을 많이 사용했습니다.       
      
그런데 ```LocalDateTime```이 제공된 이후로는 번거롭게 ```JodaDateTime``` 의존성을 따로 포함할 필요가 없어졌습니다.    
```LocalDateTime```이 대부분의 날짜 기능을 제공하기 때문입니다.     
___
도메인을 만들었으니 이에 연관된 Repository를 만들겠습니다.  

1. ```main.java.com.web.repository``` 에 ```BoardRepository``` 인터페이스 생성
2. 아래 코드 입력

**BoardRepository**
```java
package com.web.repository;

import com.web.domain.Board;
import com.web.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface BoardRepository  extends JpaRepository<Board, Long> {
    Board findByUser(User user);
}
```
```Board``` 도메인에 관련된 레포지토리를 만들었으니 ```User``` 관련 레포지토리도 만들어줍시다.      
       
1. ```main.java.com.web.repository``` 에 ```UserRepository``` 인터페이스 생성          
2. 아래 코드 입력        
           
**UserRepository**       
```java
package com.web.repository;

import com.web.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository  extends JpaRepository<User, Long> {
    User findByEmail(String email);
}
```    

## 3.4. 도메인 테스트하기     
우리는 ```Board``` 와 ```User``` 도메인을 만들었기에 이에 대한 테스트를 수행해보도록 하겠습니다.     
       
스프링 부트에서 지원하는 ```@DataJpaTest```를 사용해서 도메인을 테스트해보겠습니다.       
```@DataJpaTest```는 JPA에 대한 테스트를 지원하는 어노테이션으로 테스트 시 실행된 변경사항이 실제 DB에 반영되지는 않습니다.     
테스트를 수행하고 다시 테스트 이전의 데이터로 롤백하기 때문입니다.       
   
어차피 메모리 DB인 H2 DB를 사용해서 스프링 부트가 구동할 때마다 초기화되지만            
메모리가 아닌 하드디스크 같은 스토리지에 저장하는 디비를 사용하는 경우를 고려해서      
스프링부트에서 제공하는 JPA 전용 테스트 어노테이션을 사용해봅시다.  

```java
package com.web;

import com.web.domain.Board;
import com.web.domain.User;
import com.web.domain.enums.BoardType;
import com.web.repository.BoardRepository;
import com.web.repository.UserRepository;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.time.LocalDateTime;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.Is.is;

/**
 * Created by KimYJ on 2017-07-12.
 */
@RunWith(SpringRunner.class)
@DataJpaTest
public class JpaMappingTest {
    private final String boardTestTitle = "테스트";
    private final String email = "test@gmail.com";

    @Autowired
    UserRepository userRepository;

    @Autowired
    BoardRepository boardRepository;


    @Before
    public void init() {
        User user = userRepository.save(User.builder()
                .name("havi")
                .password("test")
                .email(email)
                .createdDate(LocalDateTime.now())
                .build());

        boardRepository.save(Board.builder()
                .title(boardTestTitle)
                .subTitle("서브 타이틀")
                .content("컨텐츠")
                .boardType(BoardType.free)
                .createdDate(LocalDateTime.now())
                .updatedDate(LocalDateTime.now())
                .user(user).build());
    }

    @Test
    public void 제대로_생성_됐는지_테스트() {
        User user = userRepository.findByEmail(email);
        assertThat(user.getName(), is("havi"));
        assertThat(user.getPassword(), is("test"));
        assertThat(user.getEmail(), is(email));

        Board board = boardRepository.findByUser(user);
        assertThat(board.getTitle(), is(boardTestTitle));
        assertThat(board.getSubTitle(), is("서브 타이틀"));
        assertThat(board.getContent(), is("컨텐츠"));
        assertThat(board.getBoardType(), is(BoardType.free));
    }

}
```
```java
@RunWith(SpringRunner.class)
```
```@RunWith()``` 어노테이션을 사용하면 JUnit에 내장된 러너를 사용하는 대신 어노테이션에 정의된 클래스를 호출합니다.   
또한 JUnit의 확장 기능을 지정하여 각 테스트시 독립적인 애플리케이션 컨텍스트를 보장합니다.    
```
어플리케이스 컨텍스트 : 빈의 생성과 관계 설정 같은 제어를 담당하는 IOC 객체를 빈 팩토리라 부르며   
이러한 빈 팩토리를 더 확장한 개념이 애플리케이션 컨텍스트입니다.
```
    
```java
@DataJpaTest
```
```@DataJpaTest``` : 스프링 부트에서 JPA 테스트를 위한 전용 어노테이션입니다.       
첫 설계 시 엔티티 간의 관계 설정 및 기능 테스트를 가능하게 도와줍니다.            
테스트가 끝날 때마다 자동 롤백을 해주어 편리한 JPA 테스트가 가능합니다.      
    
```java
@Before
```
```@Before``` : 각 테스트가 실행되기 전에 실행될 메서드를 선언합니다.    

```java
  @Test
```
```@Test``` : 실제 테스트가 진행될 메서드를 선언합니다.     
    
```java
        User user = userRepository.findByEmail(email);
        assertThat(user.getName(), is("havi"));
        assertThat(user.getPassword(), is("test"));
        assertThat(user.getEmail(), is(email));
```
각 필드의 저장된 값과 일치하는지 검사합니다.   

```java
        Board board = boardRepository.findByUser(user);
```
```init()``` 에서 저장한 board를 작성자인 user를 사용하여 조회하고 해당 필드가 올바른지 체크합니다.   
       
여기까지 완료를 했다면 테스트를 진행해보고 아래와 같은 결과가 나오시면 됩니다.     
   
[사진]   
   
___
이제 서비스와 컨트롤러를 생성하겠습니다.  
```com.web.service``` 패키지 하위에 게시판의 리스트와 폼을 찾아주며 핵심 로직을 담당하는 ```BoardService``` 클래스를 생성하겠습니다.  

1. ```com.web.service``` 에서 ```BoardService``` 클래스 생성  
2. 아래와 같은 코드를 입력합니다.  
   
**BoardService**   
```java
package com.web.service;

import com.web.domain.Board;
import com.web.repository.BoardRepository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

@Service
public class BoardService {
    private final BoardRepository boardRepository;

    public BoardService(BoardRepository boardRepository) {
        this.boardRepository = boardRepository;
    } // @RequiredArgsConstructor 로 생성해도 된다.

    public Page<Board> findBoardList(Pageable pageable){
        pageable = PageRequest.of(pageable.getPageNumber() <= 0 ? 0 : pageable.getPageNumber()-1,
                pageable.getPageSize());
        return boardRepository.findAll(pageable);
    }

    public Board findBoardByIdx(Long idx){
        return boardRepository.findById(idx).orElse(new Board());
    }

}
```
```java
@Service
```
서비스로 사용될 컴포넌트 정의 
```
스프링이 관리하는 컴포넌트에서 서비스 계층에 대해 더 명확하게 명시하는 특수한 제네릭 스테레오 형식  
```
   
```java
    public Page<Board> findBoardList(Pageable pageable){
        pageable = PageRequest.of(pageable.getPageNumber() <= 0 ? 0 : pageable.getPageNumber()-1,
                pageable.getPageSize());
        return boardRepository.findAll(pageable);
    }
```
```pageable``` 로 넘어온 ```pageNumber``` 객체가 0 이하일 때 0으로 초기화,        
기본 페이지 크기인 10으로 새로운 ```PageRequest``` 객체를 만들어 페이징 처리된 게시글 리스트 반환       
    
```java
    public Board findBoardByIdx(Long idx){
        return boardRepository.findById(idx).orElse(new Board());
    }
```
```board```의 ```idx``` 값을 사용하여 ```board``` 객체 반환        
___
URL을 통해 넘어오는 통로 역할을 하며 서비스를 통해 처리된 데이터를    
뷰 쪽에 바인딩시켜주는 ```BoardController``` 클래스를 ```com.web.controller``` 패키지 하위에 생성하겠습니다.  

1.  ```com.web.controller``` 에서 ```BoardController``` 클래스를 생성해준다.
2. 아래와 같은 코드를 입력합니다.  
   
**BoardController**
```java
package com.web.controller;

import com.web.service.BoardService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@RequestMapping("/board")
public class BoardController {
    
    @Autowired
    BoardService boardService;
    
    @GetMapping({"","/"})
    public String board(@RequestParam(value="idx", defaultValue = "0") Long idx, Model model){
        model.addAttribute("board", boardService.findBoardByIdx(idx));
        return "/board/form";
    }
    
    @GetMapping("/list")
    public String list(@PageableDefault Pageable pageable, Model model){
        model.addAttribute("boardList", boardService.findBoardList(pageable));
        return "/board/list";
    }
}
```
```java
@RequestMapping("/board")
```
API URL 경로를 ```/board```로 정의합니다.   
    
```java
    @Autowired
    BoardService boardService;
```
boardService 의존성을 주입해야 하므로 ```@Autowired```를 사용합니다.   

```java
    @GetMapping({"","/"})
```
매핑 경로를 중괄호를 사용하여 여러 개 받을 수 있습니다.     
    
```java
    @GetMapping({"","/"})
    public String board(@RequestParam(value="idx", defaultValue = "0") Long idx, Model model){
        model.addAttribute("board", boardService.findBoardByIdx(idx));
        return "/board/form";
    }
```
```@RequestParam``` 어노테이션을 사용하여 idx 파라미터를 필수로 받습니다.      
만약 바인딩할 값이 없으면 기본 값 ```0``` 으로 설정됩니다.       
```findBoardByIdx(idx)```로 조회시 idx 값을 0으로 조회하면 board값은 null 값으로 반환됩니다.      
      
```java
    @GetMapping("/list")
    public String list(@PageableDefault Pageable pageable, Model model){
        model.addAttribute("boardList", boardService.findBoardList(pageable));
        return "/board/list";
    }
```
```@PageableDefault``` 어노테이션의 파라미터인 ```size```, ```sort```, ```direction```등을 사용하여       
페이징 처리에 관한 규약을 정의할 수 있습니다.           
```src/resources/templates```를 기준으로 데이터를 바인딩할 타깃의 뷰 경로를 지정합니다.       
    
    
## 3.5. CommandLineRunner를 사용하여 DB에 데이터 넣기     

애플리케이션 구동 후 ```CommandLineRunner```로 테스트용 데이터를 DB에 넣어보겠습니다.                  
```CommandLineRunner```는 애플리케이션 구동 후 특정 코드를 실행시키고 싶을 때 직접 구현하는 인터페이스입니다.               
애플리케이션 구동시 테스트 데이터를 함께 생성하여 **데모 프로젝트를 실행/테스트하고 싶을 때 편리**합니다.             
또한 여러 ```CommandLineRunner```를 구현하여 같은 애플리케이션 컨텍스트의 빈에 사용할 수 있습니다.           
      
일단 한 명의 회원을 생성하여 그 회원이 글 200개를 작성하는 쿼리를 생성해보겠습니다.       
   
```SpringBootCommunityWebApplication``` 클래스를 아래 코드와 같이 수정합니다.      
```SpringBootCommunityWebApplication``` 클래스는 프로젝트 생성시 자동으로 생성된 Application을 의미합니다.        
필자의 경우도 ```SpringBootCommunityWebApplication```클래스로 지정되어 있으나 자신에게 맞는 Applicaiton 클래스를 찾아가면 됩니다.    
       
**SpringBootCommunityWebApplication**       
```java
package com.web;

import com.web.domain.Board;
import com.web.domain.User;
import com.web.domain.enums.BoardType;
import com.web.repository.BoardRepository;
import com.web.repository.UserRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

import java.time.LocalDateTime;
import java.util.stream.IntStream;

@SpringBootApplication
public class SpringBootCommunityWebApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBootCommunityWebApplication.class, args);
	}

	@Bean
	public CommandLineRunner runner(UserRepository userRepository, BoardRepository boardRepository)
	throws Exception{
		return (args -> {
			User user = userRepository.save(User.builder()
					.name("havi")
					.password("test")
					.email("havi@gmail.com")
					.createdDate(LocalDateTime.now())
					.build()
			);

			IntStream.rangeClosed(1,200).forEach(index -> {
				boardRepository.save(Board.builder()
						.title("게시글" + index)
						.subTitle("순서" + index)
						.content("콘텐츠")
						.boardType(BoardType.free)
						.createdDate(LocalDateTime.now())
						.updatedDate(LocalDateTime.now())
						.user(user)
						.build());
			});
			
		});
	}
}
```
```java
	@Bean
	public CommandLineRunner runner(UserRepository userRepository, BoardRepository boardRepository)
	throws Exception{
```
스프링은 빈으로 생성된 메서드에 파라미터로 ```DI(Dependency Injection)``` 시키는 메커니즘이 존재한다.       
생성자를 통해 의존성을 주입시키는 방법과 유사합니다.        
이를 이용하여 ```CommandLineRunner``` 를 빈으로 등록한 후 ```UserRepository``` 와 ```BoardRepository```를 주입받습니다.      

```
DI : 
스프링의 주요 특성중 하나로 주로 의존 관계 주입이라고 합니다.   
또는 의존 관계를 주입하는게 아니라 단지 객체의 레퍼런스를 전달하여 참조시킨다는 의미로 의존 관계 설정이라고 합니다. 
```
    
```java
			User user = userRepository.save(User.builder()
					.name("havi")
					.password("test")
					.email("havi@gmail.com")
					.createdDate(LocalDateTime.now())
					.build()
			);
```   
메서드 내부에 실행이 필요한 코드를 작성합니다.       
```User``` 객체를 **빌더 패턴**을 사용하여 생성한 후 주입받은 ```UserRepository```와 ```BoardRepository```를 주입받습니다.        
        
```   
객체의 생성 과정과 표현 방법을 분리하여 객체를 단계별 동일한 생성 절차로 복잡한 객체로 만드는 방법입니다.   
```   
  
```java
			IntStream.rangeClosed(1,200).forEach(index -> {
				boardRepository.save(Board.builder()
						.title("게시글" + index)
						.subTitle("순서" + index)
						.content("콘텐츠")
						.boardType(BoardType.free)
						.createdDate(LocalDateTime.now())
						.updatedDate(LocalDateTime.now())
						.user(user)
						.build());
			});
```   
페이징 처리 테스트를 위해 위와 동일하게 빌더 패턴을 사용합니다.          
```IntStream```의 ```rangeClosed```를 사용하여 ```index``` 순서대로 ```Board``` 객체 200개를 생성하여 저장합니다.       
      
```CommandLineRunner```와 자바 8 람다 표현식을 사용하여 깔끔하게 원하는 코드를 구현했습니다.       
```CommandLineRunner``` 에서 제안한 방법 외의 방법으로도 구현할 수 있지만, 어떤 방법을 사용하든 빈으로 등록해야합니다.     
   
## 3.6. 게시글 리스트 기능 만들기   
뷰를 구성하는데 다양한 서버 사이드 템플릿 엔진을 사용할 수 있습니다.        
타임리프 Thymeleaf, 프리마커 Freemarker, 머스타치 Mustache 등 어떠한 템플릿 엔진을 사용해도 상관없습니다.       
다만 우리는 국내에서 대중적으로 사용하는 타임리프를 사용해보도록 하겠습니다.   

```
서버 사이드 템플릿 : 
미리 정의된 HTML이 데이터를 반영하여 뷰를 만드는 작업을 서버에서 진행하고 클라이언트에 전달하는 방식을 말합니다.      
흔히 사용하는 JSP, 타임리프 등이 서버 사이드 템플릿 엔진이며         
스프링 부트 2.0 에서 지원하는 템플릿 엔진은 타임리프, 프리마커, 머스타치, 그루비 템플릿(Groovy Templates)등이 있습니다.       
```
___
이제 게시글 리스트를 만들어 보겠습니다.

1. ```src/resources/templates```에서 ```board``` 디렉토리를 생성
2. ```src/resources/templates/board``` 에서 ```list.html``` 생성

**list.html**
```html
<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Board Form</title>
    <link rel="stylesheet" th:href="@{/css/base.css}" />
    <link rel="stylesheet" th:href="@{/css/bootstrap.min.css}" />
</head>
<body>
    <div th:replace="layout/header::header"></div>

    <div class="container">
        <div class="page-header">
            <h1>게시글 목록</h1>
        </div>
        <div class="pull-right" style="width:100px;margin:10px 0;">
            <a href="/board" class="btn btn-primary btn-block">등록</a>
        </div>
        <br/><br/><br/>
        <div id="mainHide">
            <table class="table table-hover">
                <thead>
                <tr>
                    <th class="col-md-1">#</th>
                    <th class="col-md-2">서비스 분류</th>
                    <th class="col-md-5">제목</th>
                    <th class="col-md-2">작성 날짜</th>
                    <th class="col-md-2">수정 날짜</th>
                </tr>
                </thead>
                <tbody>
                    <tr th:each="board : ${boardList}">
                        <td th:text="${board.idx}"></td>
                        <td th:text="${board.boardType.value}"></td>
                        <td><a th:href="'/board?idx='+${board.idx}" th:text="${board.title}"></a></td>
                        <td th:text="${board.createdDate} ? ${#temporals.format(board.createdDate,'yyyy-MM-dd HH:mm')} : ${board.createdDate}"></td>
                        <td th:text="${board.updatedDate} ? ${#temporals.format(board.updatedDate,'yyyy-MM-dd HH:mm')} : ${board.updatedDate}"></td>
                    </tr>
                </tbody>
            </table>
        </div>
        <br/>
        <!-- Pagination -->
        <!-- /Pagination -->
    </div>

    <div th:replace="layout/footer::footer"></div>
</body>
</html>
```
```html
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
```
```th``` 는 기존의 html을 효과적으로 대체하는 네임스페이스입니다.    
```th:test``` 프로퍼티와 함께 사용하면 내부에 표현된 ```#{...}``` 구문을 실젯값으로 대체합니다.  
    
```html
    <link rel="stylesheet" th:href="@{/css/base.css}" />
    <link rel="stylesheet" th:href="@{/css/bootstrap.min.css}" />
```
```@{...}```는 타임리프의 기본 링크 표현 구문입니다.               
```server-relative``` ```URL``` 방식,               
즉 동일 서버 내의 다른 컨텍스트로 연결해주는 방식으로 서버의 루트 경로를 기준으로 구문에서 경로를 탐색하여 ```href```의 ```URL```을 대체합니다.              
     
