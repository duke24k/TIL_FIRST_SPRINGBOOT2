04 스프링 부트 웹
=======================
스프링 부트 웹 ```(spring-boot-web)``` 을 이용하여 커뮤니티 게시판을 만들어보겠습니다.    
스프링 부트 웹 ```(spring-boot-web)```은 주로 view 페이지나 API 서비스의 구현에 사용됩니다.   
  
스프링 부트 웹을 구성하는 방법은 매우 다양합니다.           
그러므로 상황에 맞는 패턴과 코드를 사용해야 합니다.                  
   
모든 방식을 담을 수는 없으니 스프링에서 제공하는 편리한 라이브러리를 어떻게 사용하는지 살펴볼겁니다.   

# 1. 커뮤니티 게시판 설계하기    

아래 그림은 전형적인 MVC 패턴으로      
사용자의 요청에 대한 데이터 처리 흐름이 애플리케이션 내부에서 어떻게 동작하는지 확인하기 위한 그림입니다.        
   
[사진]   
  
클라이언트가 서버에 데이터를 요청하면 서버가 데이터를 제공합니다.     
데이터를 요청 받은 서버는 타임리프(서버 사이드 템플릿 엔진)를 사용하여 뷰를 멋있게 구성하여 보여줍니다.      

```
타임리프 : 웹 또는 독립적인 실행 환경에서 사용되는 자바 서버 사이드 템플릿 엔진입니다.   
          세계적을 많이 쓰이고 있으며 스프링 부트에서도 공식적인 템플릿 엔진이며 스타터를 지원하고 있습니다. 
```

[사진]
  
우리는 간단한 CRUD 기능만 제공하는 게시판을 구현하겠습니다.     
   
[사진]   
   
어떤 기능을 구성할지 설계했으니 이제는 게시판을 구성하는 객체들을 명확히 정할 수 있습니다.     
필요한 게시판의 객체는 Board 와 User 입니다.         
이 두 도메인의 관계를 표현하면 위 그림과 같습니다.         
    
추가적으로 PK 는 두 테이블 모두 인덱스값으로 설정했고 글(Board)에서는 회원(User) 인덱스를 참조하여 ```1:1``` 관계로 설정했습니다.      
    
***  
# 2. 커뮤니티 게시판 프로젝트 준비하기   
인텔리제이를 사용하여 프로젝트를 생성합시다.       
    
https://github.com/kwj1270/TIL_FIRST_SPRINGBOOT2/blob/master/02%20%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%20%ED%99%98%EA%B2%BD%20%EC%84%A4%EC%A0%95.md   
   
위 주소를 참조하여 생성도록 합시다.      
**프로젝트 명은 : ```Spring-Boot-Community-Web```으로 하겠습니다.**            
   
<img width="1440" alt="스크린샷 2020-06-28 오후 3 13 00" src="https://user-images.githubusercontent.com/50267433/85939681-83ec9c00-b952-11ea-8ed5-18832eccfe33.png">
      
인텔리제이를 사용하여 프로젝트 의존 라이브러리를 생성하는 방식과              
스프링 이니셜라이저를 사용하여 의존 라이브러리를 구성하는 방식이 있습니다.       
        
```Web```, ```Thymeleaf```, ```JPA```, ```Devtools```, ```Lombok```, ```H2``` 라이브러리를 선택하여 프로젝트를 생성합니다.    
    
*** 
# 3. 커뮤니티 게시판 구현하기   
    
**개발 순서**   
   
1. 프로젝트 의존성 구성      
2. 스프링 부트 웹 스타터 살펴보기   
3. 도메인 매핑하기   
4. 도메인 테스트하기   
5. ```CommandLineRunner```를 사용하여 DB에 데이터 넣기   
6. 게시글 리스트 기능 만들기  
7. 타임리프 자바 8 날짜 포맷 라이브러리 추가하기 
8. 페이징 처리하기  
9. 작성 폼 만들기

## 3.1. 프로젝트 의존성 구성    
정상적으로 프로젝트를 구성했다면 루트 경로에 ```build.gradle```이 생성되었을겁니다.   
의존성을 다음과 같이 구성하겠습니다.    

**build.gradle**     
```gradle     
buildscript {
    ext{
        springBootVersion = '2.0.3.RELEASE'
    }
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'

group = 'com.example'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = 1.8

repositories {
    mavenCentral()
    jcenter()
}

dependencies {
    compile('org.springframework.boot:spring-boot-starter-web')
    compile('org.springframework.boot:spring-boot-starter-thymeleaf')
    compile('org.springframework.boot:spring-boot-starter-data-jpa')
    runtime('com.h2database:h2')
    runtime('org.springframework.boot:spring-boot-devtools')
    compileOnly('org.projectlombok:lombok')
    testCompile('org.springframework.boot:spring-boot-starter-test')
}

test {
    useJUnitPlatform()
}    
```   
```gradle
buildscript {
    ext{
        springBootVersion = '2.0.3.RELEASE'
    }
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}
```
```buildscript {}``` 빌드 스크립트 내부에 버전, 의존 라이브러리, 저장소를 설정해 스프링 부트 플러그인을 사용할 수 있게 합니다.       
```ext{}```, ```repositories{}```, ```dependencies{}``` 코드는 필요한 플러그인을 적용합니다.         
          
```gradle
apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'
```
종속성 관리를 제공하는 플러그인입니다.    
스프링 부트 ```1.x``` 버전에서는 기본으로 제공했지만 스프링 부트 ```2.0``` 이상에서는 플러그인 등록을 명시해주어야 합니다.      

```gradle
dependencies {
    compile('org.springframework.boot:spring-boot-starter-web')
    compile('org.springframework.boot:spring-boot-starter-thymeleaf')
    compile('org.springframework.boot:spring-boot-starter-data-jpa')
    runtime('com.h2database:h2')
    runtime('org.springframework.boot:spring-boot-devtools')
    compileOnly('org.projectlombok:lombok')
    testCompile('org.springframework.boot:spring-boot-starter-test')
}
```
프로젝트 내에 사용할 라이브러리의 의존성을 설정합니다.      
메인 부트 버전인 ```2.0.3``` 에 맞는 호환성을 가져오기 위해 디폴트 버전 사용하니다. (버전 명시도 가능하다는 말)     
   
```gradle
    runtime('com.h2database:h2')
    runtime('org.springframework.boot:spring-boot-devtools')
```
런타임 시점에만 H2 사용하도록 설정합니다.   
   
```gradle
    compileOnly('org.projectlombok:lombok')
```
```compileOnly()```는 컴파일 전용 종속성 선언 설정입니다.          
기존의 provided와 유사합니다.           
주로 컴파일 시점에만 필요하고 런타임 시점에는 필요 없을 때 많이 사용합니다.      
       
## 3.2. 스프링 부트 웹 스타터 살펴보기   
스프링 부트 웹은 웹 구성에 필요한 기본적인 요소를 담고 있습니다.   
   
밑에 코드는 스프링 부트 웹 스타터의 의존 관계 설정입니다.     
    
**스프링 부트 웹 스타터 의존 설정**    
```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>      
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-validator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-json</artifactId>
        </dependency>
       <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
        </dependency>
       <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
        </dependency>
    </dependencies>
```
* ```spring-boot-starter``` : 스프링 부트를 시작하는 기본적인 설정이 담겨 있는 스타터입니다.   
* ```spring-boot-starter-tomcat``` : 내장 톰켓을 사용하기 위한 스타터입니다.      
* ```hibernate-validator``` : 어노테이션 기반의 표준화된 제약 조건 및 유효성 검사 규칙을 표현하는 라이브러리입니다.       
* ```spring-boot-starter-json``` : jackson 라이브러리를 지원해주는 스타터입니다. JSON 데이터형의 파싱, 데이터 바인딩 함수등을 제공합니다.        
* ```spring-web``` : HTTP intergration, Servlet filters, Spring HTTP invoker 및 HTTP 코어를 포함시킨 라이브러리입니다.         
* ```spring-webmvc``` : request를 전달하는 MVC로 디자인된 DispatcherServlet 기반의 라이브러리입니다.    
    
## 3.3. 도메인 매핑하기   
이제 뷰에 데이터를 바인딩하여 반환하는 흐름을 알아보도록 하겠습니다.       
         
도메인 매핑은 JPA를 사용하여 **DB와 도메인 클래스를 연결시켜주는 작업입니다.**                    
도메인 클래스를 생성하여 H2 DB에 매핑해보겠습니다.                  
         
DB에서 (도메인을 활용하여) 레포지토리까지의 데이터 처리 흐름은 다음 그림과 같습니다.             
         
[사진]      
     
web 디렉토리 하위에 있는 domain 패키지에 설계한 Board 와 User 도메인의 클래스를 생성하겠습니다.      

1. ```main.java.com.web.domain.enums``` 에 ```BoardType``` enum 생성
2. 아래 코드 입력

**BoardType-enum**   
```java  
package com.web.domain.enums;

public enum BoardType {
    notice("공지사항"),
    free("자유게시판");
    
    private String value;
    
    BoardType(String value){
        this.value = value;
    }
    public String getValue(){
        return value;
    }
}
```
   
1. ```main.java.com.web.domain``` 에 ```Board``` 클래스 생성
2. 아래 코드 입력

**Board**
```java
package com.web.domain;

import com.web.domain.enums.BoardType;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.apache.catalina.User;

import javax.persistence.*;
import java.io.Serializable;
import java.time.LocalDateTime;

@Getter
@NoArgsConstructor
@Entity
@Table
public class Board implements Serializable {

    @Id
    @Column
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idx;

    @Column
    private String title;

    @Column
    private String subTitle;

    @Column
    private String content;
    
    @Column
    @Enumerated(EnumType.STRING)
    private BoardType boardType;
    
    @Column
    private LocalDateTime createdDate;

    @Column
    private LocalDateTime updateDate;

    @OneToOne(fetch = FetchType.LAZY)
    private User user;
    
    @Builder
    public Board(String title, String subTitle, String content, BoardType boardType, LocalDateTime createdDate, LocalDateTime updateDate, User user){
        this.title = title;
        this.subTitle = subTitle;
        this.content = content;
        this.boardType = boardType;
        this.createdDate = createdDate;
        this.updateDate = updateDate;
    }

}
```
mac os 같은 경우 ```cmd+n```을 누르면 ```[Generate]```가 뜨는데 생성자를 쉽게 만들 수 있게 해준다.     
```java
    @Id
    @Column
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idx;
```
```@GeneratedValue(strategy = GenerationType.IDENTITY)``` : 기본 키가 자동으로 할당되도록 설정하는 어노테이션       
기본키 할당 전략을 선택할 수 있는데, 키 생성을 데이터베이스에 위임하는 ```IDENTITY``` 전략을 사용했습니다.       
```
스프링 부트 1.x는 기본 키 할당 전략이 IDENTITY지만 2.x 부터는 TABLE로 변경되었습니다.    
따라서 명확히 IDENTITY로 명시하여 사용하지 않으면 한 테이블에서만 시퀀스가 관리되는 현상이 발생하게 됩니다.   
```
    
```java
    @Column
    @Enumerated(EnumType.STRING)
    private BoardType boardType;
```
```@Enumerated(EnumType.STRING)``` : Enum 타입 매핑용 어노테이션,           
```@Enumerated``` 어노테이션을 이용해 자바 ```enum```형과 데이터베이스 데이터 변환을 지원합니다.               
실제로 자바 enum 형이지만 데이터베이스의 ```String```형으로 변환하여 저장하겠다고 선언한 겁니다.        
     
```java
    @OneToOne(fetch = FetchType.LAZY)
    private User user;
```
```@OneToOne(fetch = FetchType.LAZY)``` :   
도메인 ```Board``` 와 ```Board```가 필드값으로 갖고 있는 ```User``` 도메인을 ```1:1``` 관계로 설정하는 어노테이션         
실제로 DB에 저장될 때는 ```User``` 객체가 저장되는 것이 아니라 ```User``` 의 PK인 ```user_idx``` 값이 저장됩니다.          
```fetch``` 는 ```eager``` 와 ```lazy``` 두 종류가 있는데       
```eager```는 처음 ```Board``` 도메인을 **조회할 때 즉시 관련 ```User``` 객체를 함께 조회**한다는 뜻이고.     
```lazy```는 ```User``` 객체를 조회하는 시점이 아닌 객체가 **실제 사용될 때 조회**한다는 뜻입니다.           
___

1. ```main.java.com.web.domain``` 에 ```User``` 클래스 생성
2. 아래 코드 입력    
       
**User**
```java
package com.web.domain;

import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.time.LocalDateTime;

@Getter
@NoArgsConstructor
@Entity
@Table
public class User {
    
    @Id
    @Column
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idx;
    
    @Column
    private String name;
    
    @Column
    private String password;
    
    @Column
    private String email;
    
    @Column
    private LocalDateTime createdDate;
    
    @Column
    private LocalDateTime updateDate;
    
    @Builder
    public User(String name, String password, String email, LocalDateTime createdDate, LocalDateTime updateDate) {
        this.name = name;
        this.password = password;
        this.email = email;
        this.createdDate = createdDate;
        this.updateDate = updateDate;
    }
}
```
```java
    @Column
    private LocalDateTime createdDate;
    
    @Column
    private LocalDateTime updateDate;
```
```LocalDateTime```은 자바 8에 새로 추가된 기능입니다.          
기존에는 ```Date```, ```Calendar``` 등을 주로 사용했지만 날짜 연산 기능이 많이 부족했습니다.              
그래서 종전에는 날짜에 대한 연산, 비교 등을 API로 제공하는 ```JodaDateTime``` 을 많이 사용했습니다.       
      
그런데 ```LocalDateTime```이 제공된 이후로는 번거롭게 ```JodaDateTime``` 의존성을 따로 포함할 필요가 없어졌습니다.    
```LocalDateTime```이 대부분의 날짜 기능을 제공하기 때문입니다.     
___
도메인을 만들었으니 이에 연관된 Repository를 만들겠습니다.  

1. ```main.java.com.web.repository``` 에 ```BoardRepository``` 인터페이스 생성
2. 아래 코드 입력

**BoardRepository**
```java

```
```Board``` 도메인에 관련된 레포지토리를 만들었으니 ```User``` 관련 레포지토리도 만들어줍시다.      
       
1. ```main.java.com.web.repository``` 에 ```UserRepository``` 인터페이스 생성          
2. 아래 코드 입력        
           
**UserRepository**       
```java

```    


## 3.4. 도메인 테스트하기     
우리는 ```Board``` 와 ```User``` 도메인을 만들었기에 이에 대한 테스트를 수행해보도록 하겠습니다.     
       
스프링 부트에서 지원하는 ```@DataJpaTest```를 사용해서 도메인을 테스트해보겠습니다.       
```@DataJpaTest```는 JPA에 대한 테스트를 지원하는 어노테이션으로 테스트 시 실행된 변경사항이 실제 DB에 반영되지는 않습니다.     
테스트를 수행하고 다시 테스트 이전의 데이터로 롤백하기 때문입니다.       
   
어차피 메모리 DB인 H2 DB를 사용해서 스프링 부트가 구동할 때마다 초기화되지만            
메모리가 아닌 하드디스크 같은 스토리지에 저장하는 디비를 사용하는 경우를 고려해서      
스프링부트에서 제공하는 JPA 전용 테스트 어노테이션을 사용해봅시다.  



