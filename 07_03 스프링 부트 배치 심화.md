07 스프링 부트 배치 심화
======================= 
# 6. 스프링 배치 심화 학습    
지금까지 만든 배치 처리 과정을 개선하여 더 능동적으로 테스트하는 환경으로 바꿔보겠습니다.      
  
1. 다양한 ItemReader 구현 클래스    
2. 다양한 ItemWriter 구현 클래스     
3. JobParameter 사용하기   
4. 테스트 시에만 H2 DB를 사용하도록 설정하기    
5. chunk 지향 프로세싱  
6. 배치의 인터셉터 Listener 설정하기  
7. 어노테이션 기반으로 Listener 설정하기  
8. Step의 흐름을 제어하는 Flow

## 6.1. 다양한 ItemReader 구현 클래스 
기존 작성한 배치의 테스트는 성공했지만 몇가지 해결 과제가 남았습니다.      
**바로 배치에서 제공하는 구현 클래스의 기능을 확장하는 일입니다.**   
    
스프링 배치 프로젝트에서는 각각의 상황에 맞는 다양한 ItemReader 구현체를 제공합니다.   
그중 하나가 리스트 타입으로 Reader를 구현한 ListItemReader 객체입니다.   
기존 저희가 만들었던 QueueItemReader 와 동일한 역할을 합니다.  

**InactiveUserJobConfig ListItemReader로 수정**
```java
...
    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(){
        // 그냥 여기서 처리해도 되는데 ItemReader<T>를 구현한 클래스를 반환
        // 다형성으로 ItemReader<T>에서 받아서 처리할 것이다.
        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(oldUsers); // 여러개를 받아왔구
    }
...    
```
ListItemReader 객체를 사용하도록 구현했으니 기존 QueueItemReader 객체는 삭제해도 됩니다.  
ListItemReader 객체를 사용하면 모든 데이터를 한번에 가져와 메모리에 올려놓고 read() 메서드로 하나씩 배치 처리 작업을 수행할 수 있습니다.  
  
___   

그런데 수백, 수천을 넘어 수십만 개 이상의 데이터를 한번에 가져와 메모리에 올려놓아야 할 때는 어떻게 할까요?   
이때는 배치 프로젝트에서 제공하는 PagingItemReader 구현체를 사용할 수 있습니다.   
구현체는 크게 아래와 같이 있습니다.    
     
* JdbcPagingItemReader     
* JpaPagingItemReader    
* HibernatePagingItemReader    
   
저희는 지금 JPA를 이용하고 있으므로 JpaPagingItemReader 를 사용하겠습니다.  
JpaPagingItemReader 에서는 지정한 데이터 크기만큼 DB에서 읽어오는 setPageSize() 메서드라는 기능이 있습니다.   
즉, 모든 데이터를 한번에 가져오는 것이 아니랄 지정한 단위로 가져와 배치 처리를 수행합니다.   

```
ibatisPagingReader 도 있었지만 삭제되었습니다.      
ibatisPagingReader 대신 JdbcPagingReader를 이용합시다.   
```
     
**InactiveUserJobConfig JpaPagingItemReader 추가**    
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.readers.QueueItemReader;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    private final EntityManagerFactory entityManagerFactory;
    private UserRepository userRepository; // 값 읽기 재등록을 위한 클래스

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserJpaReader()) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(){ // 리더 값을 받아온다.
        // 그냥 여기서 처리해도 되는데 ItemReader<T>를 구현한 아이템 리더를 반환
        // 다형성으로 ItemReader<T>에서 받아서 처리할 것이다.
        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(oldUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader<>();
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    public ItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        return ((List<? extends User> users) -> userRepository.saveAll(users));
    }

}
```
    
___
    
```java
    @Bean(destroyMethod="")
```
스프링에서 destroyMethod 를 사용해 삭제할 빈을 자동으로 추적합니다.   
```destroyMethod=""``` 와 같이 하여 기능을 사용하지 않도록 설정하면 실행 시 출력되는 warning 메시지를 삭제할 수 있습니다.  
   
___
   
```java

        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
```
**JpaPagingItemReader 를 사용하려면 안타깝게도 쿼리를 직접 짜서 실행하는 방법밖에는 없습니다.**    
마지막 정보 갱신 일자를 나타내는 updatedDate 파라미터와 상탯값을 나타내는 status 파라미터를 사용해 쿼리를 작성합니다.   
   
___   

```java
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
```
쿼리에서 사용된 updatedDate, status 파라미터를 Map에 추가해 사용할 파라미터를 설정합니다.   
   
___

```java
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
```
트랜잭션을 관리해줄 entityManagerFactory를 설정합니다.   
    
___

```java
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
```
한번에 읽어올 크기를 15개로 설정합니다.  
   
설정이 끝났습니다. 테스트 코드를 실행해 정삭적으로 동작하는지 확인해봅시다. -> 성공   
___
    
JpaPagingItemReader를 사용할 경우 한 가지 주의사항이 있습니다.     
바로 ```CHUNK_SIZE```입니다.     
JpaPagingItemReader 는 내부에 entityManager 를 할당받아 사용하는데 지정한 크기로 데이터를 읽어옵니다.     
만약 inactiveJobStep()에서 설정한 청크 단위 (커밋 단위)가 5라고 가정하면 Item을 5개를 write까지 배치처리를 진행하고 저장한다고 해봅시다.      

저장된 데이터를 바탕으로 다음에 다시 지정한 크기로 새 인덱스를 할당해 읽어 와야 하는데   
이전에 진행한 5라는 인덱스값을 그대로 사용해 데이터를 불러오도록 로직이 짜여 있어서 문제가 됩니다.    
예를 들어 청크 단위로 5개를 커밋하고 다음 청크 단위로 넘어가야하는 경우를 가정하겠습니다.   
하지만 entityManager에서 앞서 처리된 Item 5개 때문에 새로 불러올 Item의 인덱스 시작점이 5로 설정 되어있게 됩니다.    
그러면 쿼리 요청 시 offset 5, limit 5 이므로 개념상 바로 다음 청크 단위인 Item을 건너뛰는 상황이 발생합니다.  

이러한 상황에서 가장 간단한 해결 방법은 조회용 인덱스값을 항상 0으로 반환하는 것입니다.   
0으로 반환하면 Item 5개를 수정하고 다음 5개를 건너뛰지 않고 원하는 순서/청크 단위로 처리가 가능해집니다.   

**0으로 반환**
```java
@Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }
```

**전체 코드**
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.readers.QueueItemReader;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    private final EntityManagerFactory entityManagerFactory;
    private UserRepository userRepository; // 값 읽기 재등록을 위한 클래스

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 15 사이즈마다.
                .reader(inactiveUserJpaReader()) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(){ // 리더 값을 받아온다.
        // 그냥 여기서 처리해도 되는데 ItemReader<T>를 구현한 아이템 리더를 반환
        // 다형성으로 ItemReader<T>에서 받아서 처리할 것이다.
        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(oldUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    public ItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        return ((List<? extends User> users) -> userRepository.saveAll(users));
    }

}
```
이외에도 JdbcPagingItemReader, HibernatePagingItemReader 등 다양한 Reader 구현체가 있습니다.   
상황에 맞게 알맞은 구현체를 선택해 사용해보기 바랍니다.    

## 6.2. 다양한 ItemWriter 구현 클래스  
ItemWriter 도 ItemReader와 마찬가지로 상황에 맞는 여러 구현 클래스를 제공합니다.       
Reader 와 마찬가지로 JPA 를 사용하고 있으므로 JpaItemWriter를 적용합니다.           

InactiveUserJobConfig 의 ItemWriter 부분을 아래와 같이 수정해줍시다.   

**ItemWriter 수정**
```java
    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }
```

**InactiveUserJobConfig**
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.readers.QueueItemReader;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JpaItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    private final EntityManagerFactory entityManagerFactory;
    private UserRepository userRepository; // 값 읽기 재등록을 위한 클래스

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserJpaReader()) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(){ // 리더 값을 받아온다.
        // 그냥 여기서 처리해도 되는데 ItemReader<T>를 구현한 아이템 리더를 반환
        // 다형성으로 ItemReader<T>에서 받아서 처리할 것이다.
        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(oldUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }

}
```
JpaItemWriter는 별도로 저장 설정을 할 필요 없이 제네릭에 저장할 타입을 명시하고     
EntityManagerFactory 만 설정하면 Processor에서 넘어온 데이터를 청크 단위로 저장합니다.     
      
이밖에도 JdbcBatchItemWriter, HibernateItemWriter 등 여러 Writer 구현 클래스가 있습니다.    

## 6.3. JobParameter 사용하기   
JobParameter 를 사용해 Step 을 실행시킬 때 동적으로 파라미터를 주입시킬 수 있습니다.     

휴면회원으로 전환하는 배치 로직에서 현재 시간 기준으로 1년 전의 날짜를 값으로 사용해 휴면전환 User를 조회했습니다.      
이 경우 청크 단위로 Reader가 실행될 때마다 미세하게 현재 날짜값이 차이가 날 수 있습니다.       
JobParameter 에 현재 날짜 시간을 주입해 Reader 가 실행될 때마다 모두 동일한 시간을 참조하게 설정해봅시다.       

먼저 테스트 코드에 JobParameter 를 생성해 JobLauncher에 전달하게끔 수정합니다.    

**InactiveUserJobTest**
```java
package com.community.batch;

import com.community.batch.repository.UserRepository;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.test.JobLauncherTestUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.time.LocalDateTime;
import java.util.Date;

import static org.junit.Assert.assertEquals;
import static com.community.batch.domain.enums.UserStatus.ACTIVE;


@RunWith(SpringRunner.class)
@SpringBootTest
public class InactiveUserJobTest {

    @Autowired
    private JobLauncherTestUtils jobLauncherTestUtils;

    @Autowired
    private UserRepository userRepository;

    @Test
    public void 휴면_회원_전환_테스트() throws Exception {
        Date nowDate = new Date();
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(
                new JobParametersBuilder().addDate("nowDate", nowDate)
                .toJobParameters());

        assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());
        assertEquals(11, userRepository.findAll().size());
        assertEquals(0, userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), ACTIVE).size());
    }
}
```
   
___
   
```java
        Date nowDate = new Date();
```
현재 날짜를 Date 타입으로 생성합니다.   
Date 타입은 JobParameter 에서 허용하는 파라미터 중 하나입니다.   
   
___
   
```java
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(
                new JobParametersBuilder().addDate("nowDate", nowDate)
                .toJobParameters());
```
JobParametersBuilder 를 사용하면 간편하게 JobParameters를 생성할 수 있습니다.   
JobParameters는 여러 JobParameter 를 받는 객체입니다.     
JobLauncher를 사용하려면 JobParameters가 필요합니다.   
   
___
   
주입된 JobParameter를 실질적으로 사용하도록 코드를 수정합시다.   
inactiveJobStep() 과 inactiveUserReader() 메서드를 다음과 같이 수정합니다.   

```java
    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, ListItemReader<User> inactiveUserReader){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 15 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(@Value("#{jobParameters[nowDate]}") Date nowDate, UserRepository userRepository){ 
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
        List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(now.minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(inactiveUsers); // 여러개를 받아왔구
    }
```

**InactiveUserJobConfig 전체 코드**     
```java
package com.community.batch.jobs.inactive;


import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.repository.UserRepository;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.database.JpaItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    private final EntityManagerFactory entityManagerFactory;

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, ListItemReader<User> inactiveUserReader){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(@Value("#{jobParameters[nowDate]}") Date nowDate, UserRepository userRepository){
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
        List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(now.minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(inactiveUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }

}
```

### 기존에 정의 되어 있던 ```private UserRepository userRepository;``` 는 삭제해주어야 한다.  
 
___
   
```java
    public ListItemReader<User> inactiveUserReader(@Value("#{jobParameters[nowDate]}") Date nowDate, UserRepository userRepository){
```
SpEL을 사용해 JobParameters 에서 nowDate 파라미터를 전달받습니다.     
Date 타입으로 주입해서 곧바로 Date 타입으로 전달받을 수 있습니다.         
   
___   
    
```java
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
```
전달받은 현재 날짜값을 UserRepository 에서 사용할 수 있는 타입인 LocalDateTime 으로 전환합니다.   
   
___   
   
JobParameter 를 사용할 수 있도록 코드 수정이 끝났습니다.    
이제는 모든 배치 처리가 동일한 날짜값을 기준으로 동작합니다.   
   
## 6.4. 테스트 시에만 H2 데이터베이스를 사용하도록 설정하기   
현재까지 H2를 사용해 메모리에 데이터를 올려놓고 테스트했습니다.   
하지만 MySQL을 사용하는데 테스트에 H2를 사용하고 싶다면 어떻게 할까요?    
   
우선 build.gradle 파일에 MySQL 런타임 의존성을 추가합니다.   

**build.gradle*
```gradle
buildscript {
    ext {
        springBootVersion = '2.0.3.RELEASE'
    }
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'

group = 'com.community'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = 1.8

repositories {
    mavenCentral()
    jcenter()
}


dependencies {
    compile('org.springframework.boot:spring-boot-starter-batch')
    compile('org.springframework.boot:spring-boot-starter-data-jpa')
    runtime('com.h2database:h2')
    runtime('mysql:mysql-connector-java')
    compileOnly('org.projectlombok:lombok')
    testCompile('org.springframework.boot:spring-boot-starter-test')
    testCompile('org.springframework.batch:spring-batch-test')
}
```
이와 같이 스프링 부트에서는 의존성, 프로퍼티 설정만 하면 간단하게 MySQL을 연동시킬 수 있습니다.   
다음으로 application.yml 에 datasource 프로퍼티를 추가해 배치 애플리케이션 실행시 MySQL이 적용되어 실행되게 해봅시다.   
    
**application**
```yml
spring:
    datasource:
      url: jdbc:mysql://
      username:
      password:
      driver-class-name: com.mysql.jdbc.Driver
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: create
  batch:
    job:
      enabled: false #어플리케이션 구동시 컨텍스트 내의 모든 스프링 배치 작업 자동 실행 여부(false로 해야 구동시 무조건 실행이 안됨)
```
DB명, 아이디, 패스워드에 알맞은 정보를 넣습니다.      
이제 배치 애플리케이션 실행에는 MySQL이 기본 데이터베이스로 할당되어 사용됩니다.      
주의할 점은 만약 실제 서비스를 운영하는 프로젝트를 개발한다면 ```jpa.hibernate.ddl-auto = create``` 설정 그대로 하면 안됩니다.      
설정을 그대로 사용하면 애플리케이션을 재기동할 때마다 테이블이 삭제되고 새로 생성되는 악몽을 겪게 될 것입니다.      
   
실제로는 MySQL을 사용하지만 ```@AutoConfigureTestDatabase``` 어노테이션을 사용하면 테스트시에는 H2를 할당하게 처리할 수 있습니다.   

**InactiveUserJobTest**
```java
package com.community.batch;

import com.community.batch.repository.UserRepository;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.test.JobLauncherTestUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.jdbc.EmbeddedDatabaseConnection;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.time.LocalDateTime;
import java.util.Date;

import static org.junit.Assert.assertEquals;
import static com.community.batch.domain.enums.UserStatus.ACTIVE;


@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2)
public class InactiveUserJobTest {

    @Autowired
    private JobLauncherTestUtils jobLauncherTestUtils;

    @Autowired
    private UserRepository userRepository;

    @Test
    public void 휴면_회원_전환_테스트() throws Exception {
        Date nowDate = new Date();
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(
                new JobParametersBuilder().addDate("nowDate", nowDate)
                .toJobParameters());

        assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());
        assertEquals(11, userRepository.findAll().size());
        assertEquals(0, userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), ACTIVE).size());
    }
}
```
```@AutoConfigureTestDatabase``` 어노테이션은 datasource 프로퍼티를 기반으로 자동으로 설정된 데이터베이스를 무시하고       
테스트용 클래스에서 사용할 데이터베이스가 적용되게끔 하는 어노테이션입니다.             
예제에서와 같이 connection 설정에 H2, DERBY, HSQL 등의 테스트 데이터 케이스를 설정할 수 있습니다.         
  
## 6.5. Chunk 지향 프로세싱     
청크 지향 프로세싱은 트랜잭션 경계 내에서 청크 단위로 데이터를 읽고 생성하는 프로그래밍 기법입니다.     
청크란 아이템이 트랜잭션에서 커밋되는 수를 말합니다.      
read한 데이터 수가 지정한 청크 단위와 일치하면 write를 수행하고 트랜잭션을 커밋합니다. (Step 설정에서 chunk()로 커밋 단위 지정)       

그렇다면 청크 지향 프러세싱의 이점은 무엇일까요?       
기존에는 1000여 개의 데이터에 대해 배치 로직을 실행했을 시 1개라도 실패하면 999개가 롤백됩니다.      
그러나 청크 단위를 10으로 해서 배치 처리를 하면 도중에 배치 처리에 실패하더라도 다른 청크는 영향을 받지 않습니다.     
이러한 이유로 스프링 배치에서는 청크 단위의 프로그래밍 기법을 지향합니다.   
   
[사진]     
      
그렇다면 반대로 청크 지향 프로세싱이 아닌 방식은 무엇일까?   
여기에는 Tasklet을 사용한 방식이 있습니다.    
Tasklet은 임의의 Step을 실행할 때 하나의 작업으로 처리하는 방식입니다.   
읽기, 처리, 쓰기로 나뉜 방식이 청크 지향 프로세싱이라면 이를 단일 작업으로 만드는 개념이 Tasklet이라 할 수 있습니다.   
      
**스프링 배치 코어의 Tasklet**      
```java
package org.springframework.batch.core.step.tasklet;

import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.repeat.RepeatStatus;

public interface Tasklet {
	RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;

}
```    
Tasklet 인터페이스는 ```execution()``` 메서드 하나만 제공합니다.    
내부에 원하는 단일 작업을 구현하고    
작업이 끝나면 RepeatStatus.FINISHED를 반환하고     
작업이 계속된다면 RepeatStatus.CONTINUABLE을 반환합니다.     
   
휴면회원 배치 처리를 Tasklet으로 구현해보겠습니다.     

* ```/com/community/batch/jobs/inactive``` 에서 InactiveItemTasklet 클래스를 만들어준다.   

**InactiveItemTasklet**
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.repository.UserRepository;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@AllArgsConstructor
@Component
public class InactiveItemTasklet implements Tasklet {

    private UserRepository userRepository;

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        // reader
        Date nowDate = (Date) chunkContext.getStepContext().getJobParameters().get("nowDate");
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
        List<User> inactiveUsers = userRepository
                .findByUpdatedDateBeforeAndStatusEquals(now.minusYears(1), UserStatus.ACTIVE);
        
        // processor
        inactiveUsers = inactiveUsers.stream().map(User::setInactive).collect(Collectors.toList());
        
        // writer
        userRepository.saveAll(inactiveUsers);
        
        return RepeatStatus.FINISHED;
    }
}
```
기존의 ```읽기 -> 처리 -> 쓰기``` 로 진행되었던 청크 치향 프로세싱 방식의 구조를 하나로 합쳐놓은 것입니다.       
    
## 6.6. 배치의 인터셉터 Listener 설정하기   
배치흐름에서 전후 처리를 하는 Listener를 설정할 수 있습니다.   
구체적으로 Job의 전후 처리, Step의 전후 처리, 각 청크 단위에서의 전후 처리 등 세세한 과정 실행 시 특정 로직을 할당해 제어할 수 있습니다.      
이해를 돕기 위해 Job의 실행 전후에 Job을 실행한다는 메시지와 실행이 종료됐다는 간단한 메시지 로그를 추가해봅시다.   
   
스프링 배치에서는 Job의 Listener로 JobExecutionListener 인터페이스를 제공합니다.   
이 인터페이스를 활용해서 다음과 같이 작성해봅니다.   

* ```/com/community/batch/jobs/inactive/listener``` 에서 InactiveJobListener 클래스를 생성한다.   

**InactiveJobListener**
```java
package com.community.batch.jobs.inactive.listener;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class InactiveJobListener implements JobExecutionListener {

    @Override
    public void beforeJob(JobExecution jobExecution) {
        log.info("Before Job");
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        log.info("After Job");
    }
}
```
  
___
   
```java
@Slf4j
```
필드에 로그 객체를 따로 생성할 필요 없이 로그 객체를 사용할 수 있도록 설정하는 롬복 어노테이션 
   
___
     
```java
@Component
```
외부에서 InactiveJobListener를 주입받아서 사용할 수 있게 스프링 빈으로 등록   
   
___
     
```java
public class InactiveJobListener implements JobExecutionListener {
```
Job 실행 전후에 특정 로직을 담을 수 있도록 제공되는 인터페이스   
      
___
   
```java
    @Override
    public void beforeJob(JobExecution jobExecution) {
        log.info("Before Job");
    }
```
Job 실행 전에 수행될 로직을 구현하는 메서드   
   
___
   
```java
    @Override
    public void afterJob(JobExecution jobExecution) {
        log.info("After Job");
    }
```
Job 실행 후에 수행될 로직을 구현하는 메서드  
   
___
   
이제 Job 설정에 Listener를 등록해보자  

```java
    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록 
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }
```
	
**InactiveUserJobConfig**
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.inactive.listener.InactiveJobListener;
import com.community.batch.repository.UserRepository;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.database.JpaItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    private final EntityManagerFactory entityManagerFactory;

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, ListItemReader<User> inactiveUserReader){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(@Value("#{jobParameters[nowDate]}") Date nowDate, UserRepository userRepository){
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
        List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(now.minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(inactiveUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }

}
```
Job 정보를 설정하는 inactiveUserJob() 메서드에 InactiveJobListener를 추가했습니다.     
이제 배치 테스트를 실행해보면 출력되는 메시지는 다음과 같습니다.     

**결과**
```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.3.RELEASE)

...

2020-08-19 13:56:03.396  INFO 10296 --- [           main] c.c.b.j.i.listener.InactiveJobListener   : Before Job
2020-08-19 13:56:03.407  INFO 10296 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [inactiveUserStep]
2020-08-19 13:56:03.505  INFO 10296 --- [           main] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
Hibernate: select user0_.idx as idx1_1_, user0_.created_date as created_2_1_, user0_.email as email3_1_, user0_.grade as grade4_1_, user0_.name as name5_1_, user0_.password as password6_1_, user0_.principal as principa7_1_, user0_.social_type as social_t8_1_, user0_.status as status9_1_, user0_.updated_date as updated10_1_ from user user0_ where user0_.updated_date<? and user0_.status=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 13:56:03.770  INFO 10296 --- [           main] c.c.b.j.i.listener.InactiveJobListener   : After Job

...

Process finished with exit code 0
```  
로그 메시지는 사용자 환경에 따라 다를 수 있지만      
```'Before Job'``` , ```'After Job'``` 로그가 찍힌다면 성공적으로 Listener 가 등록된 것입니다.    
    
JobExecutionListener 인터페이스 외에도 Listener로 제공되는 인터페이스는 다음과 같습니다.   
     
**배치에서 제공되는 Listener 인터페이스와 어노테이션**     
```java
아직 패스 
```
   
## 6.7. 어노테이션 기반으로 Listener 설정하기   
이번에는 인터페이스 대신 어노테이션을 사용해 Listener 설정을 해봅시다.   
Step 실행 전후 처리 어노테이션인 ```@BeforeStep``` , ```@AfterStep```을 사용해 Step 시작 전후에 로그 메시지를 출력해보겠습니다.   

* ```/com/community/batch/jobs/inactive/listener``` 에서 InactiveStepListener 클래스 생성

**InactiveStepListener**
```java
package com.community.batch.jobs.inactive.listener;

import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.annotation.AfterStep;
import org.springframework.batch.core.annotation.BeforeStep;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class InactiveStepListener {

    @BeforeStep
    public void beforeStep(StepExecution stepExecution) {
        log.info("Before Step");
    }

    @AfterStep
    public void afterStep(StepExecution stepExecution) {
        log.info("After Step");
    }
}
```
기존 JobListener와 방식이 비슷합니다.   
다만 StepExecutionListener 인터페이스를 구현하지 않고    
```@BeforeStep```, ```@AfterStep``` 어노테이션을 사용해 동작하도록 만들었습니다.      
   
___  
    
다음은 InactiveStepListener를 Step의 Listener로 설정하게끔 InactiveUserJobConfig 를 수정하겠습니다.   
   
**InactiveUserJobConfig 내용 변경**
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.inactive.listener.InactiveJobListener;
import com.community.batch.jobs.inactive.listener.InactiveStepListener;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.database.JpaItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    private final EntityManagerFactory entityManagerFactory;

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, InactiveStepListener inactiveStepListener, ListItemReader<User> inactiveUserReader){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .listener(inactiveStepListener)
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(@Value("#{jobParameters[nowDate]}") Date nowDate, UserRepository userRepository){
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
        List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(now.minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(inactiveUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }

}
```   
inactiveJobStep 빈의 설정에서 listener(InactiveStepListener)를 추가해 InactiveStepListener 등록이 끝났습니다.      
배치 테스트를 실행시켜 정상적으로 Listener가 등록되었는지 확인해봅시다.   
다음과 같이 출력되면 정상 등록된 것입니다.      
    
**결과**
```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.3.RELEASE)

...

2020-08-19 13:56:03.396  INFO 10296 --- [           main] c.c.b.j.i.listener.InactiveJobListener   : Before Job
2020-08-19 13:56:03.396  INFO 10296 --- [           main] c.c.b.j.i.listener.InactiveJobListener   : Before Step

2020-08-19 13:56:03.407  INFO 10296 --- [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [inactiveUserStep]
2020-08-19 13:56:03.505  INFO 10296 --- [           main] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
Hibernate: select user0_.idx as idx1_1_, user0_.created_date as created_2_1_, user0_.email as email3_1_, user0_.grade as grade4_1_, user0_.name as name5_1_, user0_.password as password6_1_, user0_.principal as principa7_1_, user0_.social_type as social_t8_1_, user0_.status as status9_1_, user0_.updated_date as updated10_1_ from user user0_ where user0_.updated_date<? and user0_.status=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, principal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 13:56:03.770  INFO 10296 --- [           main] c.c.b.j.i.listener.InactiveJobListener   : After Job
2020-08-19 13:56:03.770  INFO 10296 --- [           main] c.c.b.j.i.listener.InactiveJobListener   : After Step
...

Process finished with exit code 0
``` 
   
## 6.8. Step 흐름을 제어하는 Flow   
지금까지 Step 과정의 가장 기본은 '일기-처리-쓰기' 였습니다.           
하지만 더 세부적인 조건이 추가된다면 어떻게 해야 될까요?               
특정 조건에 따라 Step의 실행 여부를 정할 수 있을까요?       
      
이러한 상황에 대비해 스프링 배치에서는 흐름을 제어하는 Flow를 제공합니다.        
그럼 랜덤하게 정수를 생성해 양수면 Step 을 실행하고 음수면 아무런 행동도 취하지 않도록 Flow를 사용해 설정해봅시다.    
    
[그림]    
   
위 그림의 흐름에서 조건에 해당하는 부분을 JobExecutionDecider 인터페이스를 사용해 구현할 수 있습니다.       
JobExecutionDecider 인터페이스는 decide() 메서드 하나만 제공합니다.       
JobExecutionDecider 는 스프링 배치 코어에 존재합니다.   

**JobExecutionDecider**
```java
package org.springframework.batch.core.job.flow;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;

public interface JobExecutionDecider {

	FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution);

}
``` 
decide() 메서드의 반환값으로 FlowExecutionStatus 객체를 반환하도록 명시되어 있습니다.      
FlowExecutionStatus 객체는 상탯값 COMPLETED, STOPPED, FAILED, UNKNOWN 등을 제공합니다.      
이 상탯값으로 Step 실행 여부를 판별하도록 설정합니다.    
   
* ```/com/community/batch/jobs/inactive``` 에서 InactiveJobExecutionDecider 클래스를 생성한다.   

**InactiveJobExecutionDecider**
```java
package com.community.batch.jobs.inactive;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.core.job.flow.JobExecutionDecider;

import java.util.Random;

@Slf4j
public class InactiveJobExecutionDecider implements JobExecutionDecider {

    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
        if(new Random().nextInt() > 0){
            log.info("FlowExecutionStatus.COMPLETED");
            return FlowExecutionStatus.COMPLETED;
        }
        log.info("FlowExecutionStatus.FAILED");
        return FlowExecutionStatus.FAILED;
    }
}
```
   
___
   
```java
        if(new Random().nextInt() > 0){
```
Random 객체를 사용해 랜덤한 정숫값을 생성하고 양수인지 확인합니다.   
  
___
   
```java
            return FlowExecutionStatus.COMPLETED;
```
양수면 FlowExecutionStatus.COMPLETED 를 반환한다.   

___  

```java

```
음수면 FlowExecutionStatus.FAILED 를 반환한다.    
   
___
   
Flow의 조건으로 사용될 InactiveJobExecutionDecider 클래스를 구현했습니다.      
이제 이를 사용할 Flow를 구현해봅시다.      
inactiveUserJob() 메서드에는 Step이 아닌 Flow 를 주입받고, 주입받을 Flow 를 inactiveJobFlow() 메서드를 통해 빈으로 등록합니다.     

```java
    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Flow inactiveJobFlow) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(inactiveJobFlow) // step 실행
                .end()
                .build(); // 빌드
    }

    @Bean
    public Flow inactiveJobFlow(Step inactiveJobStep){
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("inactiveJobFlow");
        return flowBuilder
                .start(new InactiveJobExecutionDecider())
                .on(FlowExecutionStatus.FAILED.getName()).end()
                .on(FlowExecutionStatus.COMPLETED.getName()).to(inactiveJobStep).end();
    }
```

**InactiveUserJobConfig**
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.inactive.listener.InactiveJobListener;
import com.community.batch.jobs.inactive.listener.InactiveStepListener;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.job.builder.FlowBuilder;
import org.springframework.batch.core.job.flow.Flow;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.database.JpaItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    private final EntityManagerFactory entityManagerFactory;

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Flow inactiveJobFlow) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(inactiveJobFlow) // step 실행
                .end()
                .build(); // 빌드
    }

    @Bean
    public Flow inactiveJobFlow(Step inactiveJobStep){
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("inactiveJobFlow");
        return flowBuilder
                .start(new InactiveJobExecutionDecider())
                .on(FlowExecutionStatus.FAILED.getName()).end()
                .on(FlowExecutionStatus.COMPLETED.getName()).to(inactiveJobStep).end();
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, InactiveStepListener inactiveStepListener, ListItemReader<User> inactiveUserReader){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .listener(inactiveStepListener)
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(@Value("#{jobParameters[nowDate]}") Date nowDate, UserRepository userRepository){
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
        List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(now.minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(inactiveUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }
}
```
   
___


```java
    @Bean
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("inactiveJobFlow");
```
FlowBuilder 를 사용하면 Flow 생성을 한결 편하게 할 수 있습니다.  
FlowBuilder 의 생성자에 원하는 Flow 이름을 넣어서 생성합니다.   
여기서는 ```inactiveJobFlow``` 라 지정했습니다.   
    
___

```java
        return flowBuilder
                .start(new InactiveJobExecutionDecider())
                .on(FlowExecutionStatus.FAILED.getName()).end()
                .on(FlowExecutionStatus.COMPLETED.getName()).to(inactiveJobStep).end();
```    
* 앞서 조건을 처리하는 InactiveJobExecutionDecider 클래스를 start()로 설정하여 맨 처음 시작되도록 지정합니다.   
* InactiveJobExecutionDecider 클래스의 decide() 메서드를 거쳐    
반환값으로 FlowExecutionStatus.FAILED 나올경우 end()를 사용해 곧바로 끝나도록 설정      
* InactiveJobExecutionDecider 클래스의 decide() 메서드를 거쳐    
반환값으로 FlowExecutionStatus.COMPLETED 나올경우 기존에 inactiveJobStep 를 실행하도록 설정   
    
___
   
```java
    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Flow inactiveJobFlow) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(inactiveJobFlow) // step 실행
                .end()
                .build(); // 빌드
    }
```
inactiveUserJob 시작시 Flow를 거쳐 Step을 실행하도록 inactiveJobFlow를 Start()에 설정합니다.   
   
___
   
테스트 결과를 살펴보겠습니다.   

**결과**
```
테스트는 성공, 결과는 나오지 않았습니다.   
```

***
# 7. 멀티 스레드로 여러 개의 Step 실행하기      
보통은 배치 처리당 스레드 하나만 실행할 경우가 대부분이지만 상황에 따라 여러 Step을 동시에 실행하는 경우도 있습니다.     
스프링 부트 배치는 멀티 스레드로 Step을 실행하는 여러 전략을 제공합니다.           
지금부터 다음 3 가지 방법을 알아봅시다.      
       
* TaskExecutor를 사용해 여러 Step 동작시키기     
* 여러 개의 Flow 실행시키기      
* 파티셔닝을 사용한 병렬 프로그래밍       
    
## 7.1. TaskExecutor 를 사용해 여러 Step 동작시키기    
TaskExecutor 인터페이스는 멀티 스레드로 Step을 실행하는 가장 기본적인 방법입니다.        
Task는 Runnable 인터페이스를 구현해 각각의 스레드가 독립적으로 실행되도록 작업을 할당하는 객체입니다.       
스프링에서는 이러한 Task를 실행하는 객체를 TaskExecutor 인터페이스를 통해 구현하도록 정의했습니다.     
    
TaskExecutor 인터페이스를 구현한 객체가 여렷 있지만 여기서는    
스레드를 요청할 때마다 스레드를 새로 생성하는 SimpleAsyncTaskExecutor 객체를 사용할 것입니다.   
    
___  
   
다음은 휴면회원 배치 처리(InactiveUserJobConfig)에 TaskExecutor를 등록해 멀티 스레드로 실행하도록 설정한 코드입니다.     

```java
    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, InactiveStepListener inactiveStepListener, ListItemReader<User> inactiveUserReader, TaskExecutor taskExecutor){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .taskExecutor(taskExecutor)
                .throttleLimit(2)
                .listener(inactiveStepListener)
                .build();
    }
   
    @Bean
    public TaskExecutor taskExecutor(){
        return new SimpleAsyncTaskExecutor("Batch_Task");
    }
    
```
    
**InactiveUserJobConfig**
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.inactive.listener.InactiveJobListener;
import com.community.batch.jobs.inactive.listener.InactiveStepListener;
import com.community.batch.jobs.readers.QueueItemReader;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.job.builder.FlowBuilder;
import org.springframework.batch.core.job.flow.Flow;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.database.JpaItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.core.task.TaskExecutor;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    private final EntityManagerFactory entityManagerFactory;

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Flow inactiveJobFlow) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(inactiveJobFlow) // step 실행
                .end()
                .build(); // 빌드
    }

    @Bean
    public Flow inactiveJobFlow(Step inactiveJobStep){
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("inactiveJobFlow");
        return flowBuilder
                .start(new InactiveJobExecutionDecider())
                .on(FlowExecutionStatus.FAILED.getName()).end()
                .on(FlowExecutionStatus.COMPLETED.getName()).to(inactiveJobStep).end();
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, InactiveStepListener inactiveStepListener, ListItemReader<User> inactiveUserReader, TaskExecutor taskExecutor){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .taskExecutor(taskExecutor)
                .throttleLimit(2)
                .listener(inactiveStepListener)
                .build();
    }

    @Bean
    public TaskExecutor taskExecutor(){
        return new SimpleAsyncTaskExecutor("Batch_Task");
    }

    /*
    @Bean
    @StepScope
    public QueueItemReader<User> inactiveUserReader(){ // 매개변수에 UserRepository userRepository 추가로 넣어주자
        List<User> oldUsers =
                userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new QueueItemReader<>(oldUsers); // 여러개를 받아왔구
    }
    */

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(@Value("#{jobParameters[nowDate]}") Date nowDate, UserRepository userRepository){
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
        List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(now.minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(inactiveUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }

}
```
    
___
    
```java
                .taskExecutor(taskExecutor)
                .throttleLimit(2)
```
* 빈으로 생성한 taskExecutor 를 등록합니다.     
* throttleLimit() 설정은 '설정된 제한 횟수만큼만 스레드를 동시에 실행시키겠다'는 뜻입니다.     
따라서 시스템에 할당된 스레드 풀의 크기보다 작은 값으로 설정되어야 합니다.     
만약 1로 설정하면 기존의 동기화 방식과 동일한 방식으로 실행됩니다.      
2로 설정하면 스레드를 2개씩 실행시킵니다.     
     
___
   
```java
    @Bean
    public TaskExecutor taskExecutor(){
        return new SimpleAsyncTaskExecutor("Batch_Task");
    }
```
SimpleAsyncTaskExecutor 를 생성해 빈으로 등록합니다.        
생성자의 매개변수로 돌아가는 값은 Task에 할당되는 이름이 됩니다.      
기본적으로 첫 번째 Task는 ```Batch_Task1``` 이라는 이름으로 할당되어 뒤에 붙는 숫자가 하나씩 증가하여 이름이 정해집니다.      
      
___     
   
실행 결과 로그를 살펴보면 여러 스레드가 병렬로 실행되었기에 로그 실행 순서가 뒤죽박죽으로 표시됩니다.        

**결과**
```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.3.RELEASE)

2020-08-19 21:00:44.207  INFO 13866 --- [    Test worker] com.community.batch.InactiveUserJobTest  : Starting InactiveUserJobTest on gim-ujaeui-MacBookPro.local with PID 13866 (started by gim-ujae in /Users/gim-ujae/Documents/git/book/projects/Spring-Boot-Community-Batch)
2020-08-19 21:00:44.209  INFO 13866 --- [    Test worker] com.community.batch.InactiveUserJobTest  : No active profile set, falling back to default profiles: default
2020-08-19 21:00:44.228  INFO 13866 --- [    Test worker] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@217cb565: startup date [Wed Aug 19 21:00:44 KST 2020]; root of context hierarchy
2020-08-19 21:00:44.654  INFO 13866 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'inactiveUserJob' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=inactiveUserJobConfig; factoryMethodName=inactiveUserJob; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/InactiveUserJobConfig.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=test; factoryMethodName=inactiveUserJob; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/test.class]]
2020-08-19 21:00:44.655  INFO 13866 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'inactiveJobStep' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=inactiveUserJobConfig; factoryMethodName=inactiveJobStep; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/InactiveUserJobConfig.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=test; factoryMethodName=inactiveJobStep; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/test.class]]
2020-08-19 21:00:44.656  INFO 13866 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'taskExecutor' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=inactiveUserJobConfig; factoryMethodName=taskExecutor; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/InactiveUserJobConfig.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=test; factoryMethodName=taskExecutor; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/test.class]]
2020-08-19 21:00:44.656  INFO 13866 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'scopedTarget.inactiveUserReader' with a different definition: replacing [Root bean: class [null]; scope=step; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=false; primary=false; factoryBeanName=inactiveUserJobConfig; factoryMethodName=inactiveUserReader; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/InactiveUserJobConfig.class]] with [Root bean: class [null]; scope=step; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=false; primary=false; factoryBeanName=test; factoryMethodName=inactiveUserReader; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/test.class]]
2020-08-19 21:00:44.927  INFO 13866 --- [    Test worker] beddedDataSourceBeanFactoryPostProcessor : Replacing 'dataSource' DataSource bean with embedded version
2020-08-19 21:00:44.927  INFO 13866 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'dataSource' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari; factoryMethodName=dataSource; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration$Hikari.class]] with [Root bean: class [org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration$EmbeddedDataSourceFactoryBean]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null]
2020-08-19 21:00:45.584  INFO 13866 --- [    Test worker] o.s.j.d.e.EmbeddedDatabaseFactory        : Starting embedded database: url='jdbc:h2:mem:895201b8-7070-43c3-9bf6-93dee1fb8605;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false', username='sa'
2020-08-19 21:00:46.138  INFO 13866 --- [    Test worker] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-08-19 21:00:46.174  INFO 13866 --- [    Test worker] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-08-19 21:00:46.314  INFO 13866 --- [    Test worker] org.hibernate.Version                    : HHH000412: Hibernate Core {5.2.17.Final}
2020-08-19 21:00:46.316  INFO 13866 --- [    Test worker] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2020-08-19 21:00:46.385  INFO 13866 --- [    Test worker] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.1.Final}
2020-08-19 21:00:46.587  INFO 13866 --- [    Test worker] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
Hibernate: drop table user if exists
Hibernate: drop sequence if exists hibernate_sequence
Hibernate: create sequence hibernate_sequence start with 1 increment by 1
Hibernate: create table user (idx bigint not null, created_date timestamp, email varchar(255), grade varchar(255), name varchar(255), password varchar(255), pincipal varchar(255), social_type varchar(255), status varchar(255), updated_date timestamp, primary key (idx))
2020-08-19 21:00:47.426  INFO 13866 --- [    Test worker] o.h.t.schema.internal.SchemaCreatorImpl  : HHH000476: Executing import script 'ScriptSourceInputFromUrl(file:/Users/gim-ujae/Documents/git/book/projects/Spring-Boot-Community-Batch/build/resources/main/import.sql)'
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1001, 'test@test.com', 'test1', 'test1', 'FACEBOOK', 'ACTIVE', 'VIP', '2016-03-01T00:00:00', '2018-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1002, 'test@test.com', 'test2', 'test2', 'FACEBOOK', 'ACTIVE', 'VIP', '2016-03-01T00:00:00', '2018-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1003, 'test@test.com', 'test3', 'test3', 'FACEBOOK', 'ACTIVE', 'VIP', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1004, 'test@test.com', 'test4', 'test4', 'FACEBOOK', 'ACTIVE', 'GOLD', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1005, 'test@test.com', 'test5', 'test5', 'FACEBOOK', 'ACTIVE', 'GOLD', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1006, 'test@test.com', 'test6', 'test6', 'FACEBOOK', 'ACTIVE', 'GOLD', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1007, 'test@test.com', 'test7', 'test7', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1008, 'test@test.com', 'test8', 'test8', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1009, 'test@test.com', 'test9', 'test9', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1010, 'test@test.com', 'test10', 'test10', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1011, 'test@test.com', 'test11', 'test11', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
2020-08-19 21:00:47.436  INFO 13866 --- [    Test worker] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-08-19 21:00:48.210  WARN 13866 --- [    Test worker] o.s.b.a.batch.JpaBatchConfigurer         : JPA does not support custom isolation levels, so locks may not be taken when launching Jobs
2020-08-19 21:00:48.218  INFO 13866 --- [    Test worker] o.s.b.c.r.s.JobRepositoryFactoryBean     : No database type set, using meta data indicating: H2
2020-08-19 21:00:48.468  INFO 13866 --- [    Test worker] o.s.b.c.l.support.SimpleJobLauncher      : No TaskExecutor has been set, defaulting to synchronous executor.
2020-08-19 21:00:48.493  INFO 13866 --- [    Test worker] o.s.jdbc.datasource.init.ScriptUtils     : Executing SQL script from class path resource [org/springframework/batch/core/schema-h2.sql]
2020-08-19 21:00:48.526  INFO 13866 --- [    Test worker] o.s.jdbc.datasource.init.ScriptUtils     : Executed SQL script from class path resource [org/springframework/batch/core/schema-h2.sql] in 33 ms.
2020-08-19 21:00:48.741  INFO 13866 --- [    Test worker] com.community.batch.InactiveUserJobTest  : Started InactiveUserJobTest in 4.907 seconds (JVM running for 6.246)
2020-08-19 21:00:49.002  INFO 13866 --- [    Test worker] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=inactiveUserJob]] launched with the following parameters: [{nowDate=1597838448944}]
2020-08-19 21:00:49.013  INFO 13866 --- [    Test worker] c.c.b.j.i.listener.InactiveJobListener   : Before Job
2020-08-19 21:00:49.024  INFO 13866 --- [    Test worker] o.s.batch.core.job.SimpleStepHandler     : Executing step: [inactiveUserStep]
2020-08-19 21:00:49.028  INFO 13866 --- [    Test worker] c.c.b.j.i.listener.InactiveStepListener  : Before Step
2020-08-19 21:00:49.041  INFO 13866 --- [    Batch_Task1] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
2020-08-19 21:00:49.046  INFO 13866 --- [    Batch_Task2] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
2020-08-19 21:00:49.123  INFO 13866 --- [    Batch_Task1] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
Hibernate: select user0_.idx as idx1_0_, user0_.created_date as created_2_0_, user0_.email as email3_0_, user0_.grade as grade4_0_, user0_.name as name5_0_, user0_.password as password6_0_, user0_.pincipal as pincipal7_0_, user0_.social_type as social_t8_0_, user0_.status as status9_0_, user0_.updated_date as updated10_0_ from user user0_ where user0_.updated_date<? and user0_.status=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:00:49.367  INFO 13866 --- [    Batch_Task2] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
2020-08-19 21:00:49.368  INFO 13866 --- [    Batch_Task3] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:00:49.376  INFO 13866 --- [    Batch_Task3] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:00:49.377  INFO 13866 --- [    Batch_Task4] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:00:49.379  INFO 13866 --- [    Batch_Task4] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:00:49.384  INFO 13866 --- [    Batch_Task1] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
2020-08-19 21:00:49.386  INFO 13866 --- [    Batch_Task5] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
2020-08-19 21:00:49.389  INFO 13866 --- [    Batch_Task5] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
2020-08-19 21:00:49.389  INFO 13866 --- [    Test worker] c.c.b.j.i.listener.InactiveStepListener  : After Step
2020-08-19 21:00:49.400  INFO 13866 --- [    Test worker] c.c.b.j.i.listener.InactiveJobListener   : After Job
2020-08-19 21:00:49.403  INFO 13866 --- [    Test worker] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=inactiveUserJob]] completed with the following parameters: [{nowDate=1597838448944}] and the following status: [COMPLETED]
Hibernate: select user0_.idx as idx1_0_, user0_.created_date as created_2_0_, user0_.email as email3_0_, user0_.grade as grade4_0_, user0_.name as name5_0_, user0_.password as password6_0_, user0_.pincipal as pincipal7_0_, user0_.social_type as social_t8_0_, user0_.status as status9_0_, user0_.updated_date as updated10_0_ from user user0_
Hibernate: select user0_.idx as idx1_0_, user0_.created_date as created_2_0_, user0_.email as email3_0_, user0_.grade as grade4_0_, user0_.name as name5_0_, user0_.password as password6_0_, user0_.pincipal as pincipal7_0_, user0_.social_type as social_t8_0_, user0_.status as status9_0_, user0_.updated_date as updated10_0_ from user user0_ where user0_.updated_date<? and user0_.status=?
2020-08-19 21:00:49.462  INFO 13866 --- [       Thread-6] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@217cb565: startup date [Wed Aug 19 21:00:44 KST 2020]; root of context hierarchy
2020-08-19 21:00:49.468  INFO 13866 --- [       Thread-6] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
Deprecated Gradle features were used in this build, making it incompatible with Gradle 5.0.
See https://docs.gradle.org/4.6/userguide/command_line_interface.html#sec:command_line_warnings
BUILD SUCCESSFUL in 9s
4 actionable tasks: 3 executed, 1 up-to-date
9:00:49 오후: Task execution finished ':test --tests "com.community.batch.InactiveUserJobTest.휴면_회원_전환_테스트"'.
```
    
스레드명이 ```'Batch_Task5'``` 까지 표기되어 있으니 스레드가 총 5개 할당되었음을 알 수 있습니다.      
   
## 7.2. 여러 개의 Flow 실행시키기    
Flow 를 멀티 스레드로 실행시키는 방법을 알아보겠습니다.       
코드는 기존에 랜덤 정숫값을 사용해 Step을 실행하는 Flow 코드를 확장해서 작성합니다.     
       
사실 앞서 설정한 Flow를 멀티 스레드로 동작시키는 방법은 그리 적절하지 않습니다.      
휴면회원으로 전환될 회원 데이터를 기간별로 나눠서 각각 스레드별로 처리하는 방법이 더 적절합니다.         
하지만 지금은 사용 방법을 익히기 위해 기존에 구현한 코드에 멀티 스레드 방식을 적용하겠습니다.      
**어떤 식으로 스레드가 할당되어 Flow가 실행되는지에 초첨을 맞춰 공부하기 바랍니다.**       
    
___
   
기본 설정은 '7.1 TaskExecutor 를 사용해 여러 Step 동작시키기' 진행한 방법과 같습니다.   

```java
    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, InactiveStepListener inactiveStepListener, ListItemReader<User> inactiveUserReader, TaskExecutor taskExecutor){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .taskExecutor(taskExecutor)
                .throttleLimit(2)
                .listener(inactiveStepListener)
                .build();
    }
   
    @Bean
    public TaskExecutor taskExecutor(){
        return new SimpleAsyncTaskExecutor("Batch_Task");
    }
```

___   
   
여러 개의 Flow 를 만들어 등록하고 InactiveUserJobConfig 에서 사용해봅시다.           

```java

    private final static int CHUNK_SIZE = 5;

    private final EntityManagerFactory entityManagerFactory;

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Flow multiFlow) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(multiFlow) // step 실행
                .end()
                .build(); // 빌드
    }

    @Bean
    public Flow multiFlow(Step inactiveJobStep){
        Flow flows[] = new Flow[5];
        IntStream.range(0, flows.length).forEach(i -> flows[i] =
                new FlowBuilder<Flow>("MultiFlow"+i).from(inactiveJobFlow(inactiveJobStep)).end());
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("MultiFLowTest");
        return flowBuilder
                .split(taskExecutor())
                .add(flows)
                .build();
    }
    
    public Flow inactiveJobFlow(Step inactiveJobStep){
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("inactiveJobFlow");
        return flowBuilder
                .start(new InactiveJobExecutionDecider())
                .on(FlowExecutionStatus.FAILED.getName()).end()
                .on(FlowExecutionStatus.COMPLETED.getName()).to(inactiveJobStep).end();
    }
``` 

multiFlow() 시에 5만큼만 Flow 배열을 만들어 사용하기에 CHUNK_SIZE 를 5로 변경해주었습니다.       
 
**InactiveUserJobConfig**
```java
package com.community.batch.jobs.inactive;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.inactive.listener.InactiveJobListener;
import com.community.batch.jobs.inactive.listener.InactiveStepListener;
import com.community.batch.jobs.readers.QueueItemReader;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.job.builder.FlowBuilder;
import org.springframework.batch.core.job.flow.Flow;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.database.JpaItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.core.task.TaskExecutor;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;

// 실행할 JOB 배치
@AllArgsConstructor
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 5;

    private final EntityManagerFactory entityManagerFactory;

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Flow multiFlow) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(multiFlow) // step 실행
                .end()
                .build(); // 빌드
    }

    @Bean
    public Flow multiFlow(Step inactiveJobStep){
        Flow flows[] = new Flow[5];
        IntStream.range(0, flows.length).forEach(i -> flows[i] =
                new FlowBuilder<Flow>("MultiFlow"+i).from(inactiveJobFlow(inactiveJobStep)).end());
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("MultiFLowTest");
        return flowBuilder
                .split(taskExecutor())
                .add(flows)
                .build();
    }

    public Flow inactiveJobFlow(Step inactiveJobStep){
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("inactiveJobFlow");
        return flowBuilder
                .start(new InactiveJobExecutionDecider())
                .on(FlowExecutionStatus.FAILED.getName()).end()
                .on(FlowExecutionStatus.COMPLETED.getName()).to(inactiveJobStep).end();
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory, InactiveStepListener inactiveStepListener, ListItemReader<User> inactiveUserReader, TaskExecutor taskExecutor){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserReader) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .taskExecutor(taskExecutor)
                .throttleLimit(2)
                .listener(inactiveStepListener)
                .build();
    }

    @Bean
    public TaskExecutor taskExecutor(){
        return new SimpleAsyncTaskExecutor("Batch_Task");
    }

    /*
    @Bean
    @StepScope
    public QueueItemReader<User> inactiveUserReader(){ // 매개변수에 UserRepository userRepository 추가로 넣어주자
        List<User> oldUsers =
                userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new QueueItemReader<>(oldUsers); // 여러개를 받아왔구
    }
    */

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(@Value("#{jobParameters[nowDate]}") Date nowDate, UserRepository userRepository){
        LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());
        List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(now.minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(inactiveUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }

}
```
   
___
   
```java
    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , InactiveJobListener inactiveJobListener, Flow multiFlow) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .listener(inactiveJobListener) // 리스너 등록
                .start(multiFlow) 
                .end()
                .build(); // 빌드
    }
```
빈으로 등록한 multiFlow 설정으로 시작합니다.   
     
___  
     
```java
        Flow flows[] = new Flow[5];
        IntStream.range(0, flows.length).forEach(i -> flows[i] =
                new FlowBuilder<Flow>("MultiFlow"+i).from(inactiveJobFlow(inactiveJobStep)).end());
```  
IntStream 을 이용해 flows 배열의 크기만큼 반복문을 돌립니다.         
FlowBuilder 객체로 Flow(inactiveJobFlow) 배열 크기만큼 생성해서 flow 배열에 할당합니다.        
   
___
   
```java
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("MultiFLowTest");
        return flowBuilder
                .split(taskExecutor())
                .add(flows)
                .build();

```
* mutilFlow 에서 사용할 TaskExecutor 를 등록합니다.     
* inactiveFlow 5개(배열 크기)가 할당된 flows 배열을 추가합니다.     

___

```java
    public Flow inactiveJobFlow(Step inactiveJobStep){
        FlowBuilder<Flow> flowBuilder = new FlowBuilder<>("inactiveJobFlow");
        return flowBuilder
                .start(new InactiveJobExecutionDecider())
                .on(FlowExecutionStatus.FAILED.getName()).end()
                .on(FlowExecutionStatus.COMPLETED.getName()).to(inactiveJobStep).end();
    }
```
기존의 activeJobFlow 는 빈으로 등록되어 있습니다.        
빈은 기본적으로 싱글톤 패턴으로 등록되기 때문에      
여러 inactiveJobFlow 를 각각 생성하려면 ```@Bean``` 어노테이션을 제거하여 빈이 아닌 일반 객체를 생성해 반환하도록 설정해야 합니다.      
   
___
   
테스트 실행시 다음과 같은 결과가 출력됩니다.   

**결과**
```
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.3.RELEASE)

2020-08-19 21:38:17.074  INFO 13967 --- [    Test worker] com.community.batch.InactiveUserJobTest  : Starting InactiveUserJobTest on gim-ujaeui-MacBookPro.local with PID 13967 (started by gim-ujae in /Users/gim-ujae/Documents/git/book/projects/Spring-Boot-Community-Batch)
2020-08-19 21:38:17.077  INFO 13967 --- [    Test worker] com.community.batch.InactiveUserJobTest  : No active profile set, falling back to default profiles: default
2020-08-19 21:38:17.101  INFO 13967 --- [    Test worker] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@259fc61c: startup date [Wed Aug 19 21:38:17 KST 2020]; root of context hierarchy
2020-08-19 21:38:17.525  INFO 13967 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'inactiveUserJob' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=inactiveUserJobConfig; factoryMethodName=inactiveUserJob; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/InactiveUserJobConfig.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=test; factoryMethodName=inactiveUserJob; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/test.class]]
2020-08-19 21:38:17.525  INFO 13967 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'inactiveJobStep' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=inactiveUserJobConfig; factoryMethodName=inactiveJobStep; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/InactiveUserJobConfig.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=test; factoryMethodName=inactiveJobStep; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/test.class]]
2020-08-19 21:38:17.527  INFO 13967 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'taskExecutor' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=inactiveUserJobConfig; factoryMethodName=taskExecutor; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/InactiveUserJobConfig.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=test; factoryMethodName=taskExecutor; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/test.class]]
2020-08-19 21:38:17.529  INFO 13967 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'scopedTarget.inactiveUserReader' with a different definition: replacing [Root bean: class [null]; scope=step; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=false; primary=false; factoryBeanName=inactiveUserJobConfig; factoryMethodName=inactiveUserReader; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/InactiveUserJobConfig.class]] with [Root bean: class [null]; scope=step; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=false; primary=false; factoryBeanName=test; factoryMethodName=inactiveUserReader; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/community/batch/jobs/inactive/test.class]]
2020-08-19 21:38:17.800  INFO 13967 --- [    Test worker] beddedDataSourceBeanFactoryPostProcessor : Replacing 'dataSource' DataSource bean with embedded version
2020-08-19 21:38:17.801  INFO 13967 --- [    Test worker] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'dataSource' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari; factoryMethodName=dataSource; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration$Hikari.class]] with [Root bean: class [org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration$EmbeddedDataSourceFactoryBean]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null]
2020-08-19 21:38:18.213  INFO 13967 --- [    Test worker] o.s.j.d.e.EmbeddedDatabaseFactory        : Starting embedded database: url='jdbc:h2:mem:c99795e6-f879-4d80-94aa-2791be5bae44;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false', username='sa'
2020-08-19 21:38:18.653  INFO 13967 --- [    Test worker] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'
2020-08-19 21:38:18.697  INFO 13967 --- [    Test worker] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [
	name: default
	...]
2020-08-19 21:38:18.854  INFO 13967 --- [    Test worker] org.hibernate.Version                    : HHH000412: Hibernate Core {5.2.17.Final}
2020-08-19 21:38:18.857  INFO 13967 --- [    Test worker] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2020-08-19 21:38:18.938  INFO 13967 --- [    Test worker] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.1.Final}
2020-08-19 21:38:19.143  INFO 13967 --- [    Test worker] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
Hibernate: drop table user if exists
Hibernate: drop sequence if exists hibernate_sequence
Hibernate: create sequence hibernate_sequence start with 1 increment by 1
Hibernate: create table user (idx bigint not null, created_date timestamp, email varchar(255), grade varchar(255), name varchar(255), password varchar(255), pincipal varchar(255), social_type varchar(255), status varchar(255), updated_date timestamp, primary key (idx))
2020-08-19 21:38:19.934  INFO 13967 --- [    Test worker] o.h.t.schema.internal.SchemaCreatorImpl  : HHH000476: Executing import script 'ScriptSourceInputFromUrl(file:/Users/gim-ujae/Documents/git/book/projects/Spring-Boot-Community-Batch/build/resources/main/import.sql)'
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1001, 'test@test.com', 'test1', 'test1', 'FACEBOOK', 'ACTIVE', 'VIP', '2016-03-01T00:00:00', '2018-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1002, 'test@test.com', 'test2', 'test2', 'FACEBOOK', 'ACTIVE', 'VIP', '2016-03-01T00:00:00', '2018-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1003, 'test@test.com', 'test3', 'test3', 'FACEBOOK', 'ACTIVE', 'VIP', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1004, 'test@test.com', 'test4', 'test4', 'FACEBOOK', 'ACTIVE', 'GOLD', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1005, 'test@test.com', 'test5', 'test5', 'FACEBOOK', 'ACTIVE', 'GOLD', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1006, 'test@test.com', 'test6', 'test6', 'FACEBOOK', 'ACTIVE', 'GOLD', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1007, 'test@test.com', 'test7', 'test7', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1008, 'test@test.com', 'test8', 'test8', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1009, 'test@test.com', 'test9', 'test9', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1010, 'test@test.com', 'test10', 'test10', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
Hibernate: insert into user (idx, email, name, password, social_type, status, grade, created_date, updated_date) values (1011, 'test@test.com', 'test11', 'test11', 'FACEBOOK', 'ACTIVE', 'FAMILY', '2016-03-01T00:00:00', '2016-03-01T00:00:00')
2020-08-19 21:38:19.945  INFO 13967 --- [    Test worker] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-08-19 21:38:20.729  WARN 13967 --- [    Test worker] o.s.b.a.batch.JpaBatchConfigurer         : JPA does not support custom isolation levels, so locks may not be taken when launching Jobs
2020-08-19 21:38:20.737  INFO 13967 --- [    Test worker] o.s.b.c.r.s.JobRepositoryFactoryBean     : No database type set, using meta data indicating: H2
2020-08-19 21:38:20.986  INFO 13967 --- [    Test worker] o.s.b.c.l.support.SimpleJobLauncher      : No TaskExecutor has been set, defaulting to synchronous executor.
2020-08-19 21:38:21.008  INFO 13967 --- [    Test worker] o.s.jdbc.datasource.init.ScriptUtils     : Executing SQL script from class path resource [org/springframework/batch/core/schema-h2.sql]
2020-08-19 21:38:21.043  INFO 13967 --- [    Test worker] o.s.jdbc.datasource.init.ScriptUtils     : Executed SQL script from class path resource [org/springframework/batch/core/schema-h2.sql] in 35 ms.
2020-08-19 21:38:21.235  INFO 13967 --- [    Test worker] com.community.batch.InactiveUserJobTest  : Started InactiveUserJobTest in 4.505 seconds (JVM running for 5.805)
2020-08-19 21:38:21.487  INFO 13967 --- [    Test worker] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=inactiveUserJob]] launched with the following parameters: [{nowDate=1597840701391}]
2020-08-19 21:38:21.501  INFO 13967 --- [    Test worker] c.c.b.j.i.listener.InactiveJobListener   : Before Job
2020-08-19 21:38:21.514  INFO 13967 --- [    Test worker] o.s.batch.core.job.SimpleStepHandler     : Executing step: [inactiveUserStep]
2020-08-19 21:38:21.517  INFO 13967 --- [    Test worker] c.c.b.j.i.listener.InactiveStepListener  : Before Step
2020-08-19 21:38:21.535  INFO 13967 --- [    Batch_Task1] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
2020-08-19 21:38:21.536  INFO 13967 --- [    Batch_Task2] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
2020-08-19 21:38:21.623  INFO 13967 --- [    Batch_Task1] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
Hibernate: select user0_.idx as idx1_0_, user0_.created_date as created_2_0_, user0_.email as email3_0_, user0_.grade as grade4_0_, user0_.name as name5_0_, user0_.password as password6_0_, user0_.pincipal as pincipal7_0_, user0_.social_type as social_t8_0_, user0_.status as status9_0_, user0_.updated_date as updated10_0_ from user user0_ where user0_.updated_date<? and user0_.status=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:38:21.830  INFO 13967 --- [    Batch_Task2] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
2020-08-19 21:38:21.832  INFO 13967 --- [    Batch_Task3] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: select user0_.idx as idx1_0_0_, user0_.created_date as created_2_0_0_, user0_.email as email3_0_0_, user0_.grade as grade4_0_0_, user0_.name as name5_0_0_, user0_.password as password6_0_0_, user0_.pincipal as pincipal7_0_0_, user0_.social_type as social_t8_0_0_, user0_.status as status9_0_0_, user0_.updated_date as updated10_0_0_ from user user0_ where user0_.idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:38:21.839  INFO 13967 --- [    Batch_Task3] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:38:21.841  INFO 13967 --- [    Batch_Task4] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:38:21.843  INFO 13967 --- [    Batch_Task4] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
Hibernate: update user set created_date=?, email=?, grade=?, name=?, password=?, pincipal=?, social_type=?, status=?, updated_date=? where idx=?
2020-08-19 21:38:21.847  INFO 13967 --- [    Batch_Task1] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
2020-08-19 21:38:21.848  INFO 13967 --- [    Batch_Task5] c.c.b.j.i.l.InactiveChunkListener        : Before Chunk
2020-08-19 21:38:21.851  INFO 13967 --- [    Batch_Task5] c.c.b.j.i.l.InactiveChunkListener        : After Chunk
2020-08-19 21:38:21.851  INFO 13967 --- [    Test worker] c.c.b.j.i.listener.InactiveStepListener  : After Step
2020-08-19 21:38:21.856  INFO 13967 --- [    Test worker] c.c.b.j.i.listener.InactiveJobListener   : After Job
2020-08-19 21:38:21.858  INFO 13967 --- [    Test worker] o.s.b.c.l.support.SimpleJobLauncher      : Job: [SimpleJob: [name=inactiveUserJob]] completed with the following parameters: [{nowDate=1597840701391}] and the following status: [COMPLETED]
Hibernate: select user0_.idx as idx1_0_, user0_.created_date as created_2_0_, user0_.email as email3_0_, user0_.grade as grade4_0_, user0_.name as name5_0_, user0_.password as password6_0_, user0_.pincipal as pincipal7_0_, user0_.social_type as social_t8_0_, user0_.status as status9_0_, user0_.updated_date as updated10_0_ from user user0_
Hibernate: select user0_.idx as idx1_0_, user0_.created_date as created_2_0_, user0_.email as email3_0_, user0_.grade as grade4_0_, user0_.name as name5_0_, user0_.password as password6_0_, user0_.pincipal as pincipal7_0_, user0_.social_type as social_t8_0_, user0_.status as status9_0_, user0_.updated_date as updated10_0_ from user user0_ where user0_.updated_date<? and user0_.status=?
2020-08-19 21:38:21.937  INFO 13967 --- [       Thread-6] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@259fc61c: startup date [Wed Aug 19 21:38:17 KST 2020]; root of context hierarchy
2020-08-19 21:38:21.940  INFO 13967 --- [       Thread-6] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
Deprecated Gradle features were used in this build, making it incompatible with Gradle 5.0.
See https://docs.gradle.org/4.6/userguide/command_line_interface.html#sec:command_line_warnings
BUILD SUCCESSFUL in 9s
4 actionable tasks: 3 executed, 1 up-to-date
9:38:22 오후: Task execution finished ':test --tests "com.community.batch.InactiveUserJobTest.휴면_회원_전환_테스트"'.
```   
```'Batch_Task5'``` 까지 표기되었으며 스레드가 5개 할당되었습니다.     

## 7.3. 파티셔닝을 사용한 병렬 프로그래밍      
여기서는 Step 여러 개를 병렬로 실행시키는 파티셔닝에 대해 알아봅시다.       
     
파티셔닝의 원리는 간단합니다.       
파티셔너로 구분된 각 Step에 스레드를 할당해 병렬적으로 실행시키는 방법입니다.      
  
[사진]    
   
일련의 Step 절차 중 마스터가 있는데, 여기서 마스터를 여러 슬레이브로 나눕니다.       
슬레이브는 일반적으로 실행되는 스레드라고 생각할 수 있습니다.          
슬레이브와 마스터 모두 Step의 인스턴스입니다.           
모든 슬레이브의 작업이 완료되면 결과가 합쳐져서 마스터가 완료되고 Step이 마무리됩니다.       
      
___   
  
휴면회원으로 전환할 회원을 각 등급에 따라 병렬로 처리하게끔 파티셔닝을 구현해봅시다.      
스프링 배치에서는 파티셔닝을 어떤 전략으로 생성할지 결정하는 Partitioner 전략 인터페이스를 제공합니다.    
  
Partitioner 인터페이스는 다음과 같습니다.  

**스프링 배치 코어의 Partitioner**
```java

```



