07 스프링 부트 배치 심화
======================= 
# 6. 스프링 배치 심화 학습    
지금까지 만든 배치 처리 과정을 개선하여 더 능동적으로 테스트하는 환경으로 바꿔보겠습니다.      
  
1. 다양한 ItemReader 구현 클래스    
2. 다양한 ItemWriter 구현 클래스     
3. JobParameter 사용하기   
4. 테스트 시에만 H2 DB를 사용하도록 설정하기    
5. chunk 지향 프로세싱  
6. 배치의 인터셉터 Listener 설정하기  
7. 어노테이션 기반으로 Listener 설정하기  
8. Step의 흐름을 제어하는 Flow

## 6.1. 다양한 ItemReader 구현 클래스 
기존 작성한 배치의 테스트는 성공했지만 몇가지 해결 과제가 남았습니다.      
**바로 배치에서 제공하는 구현 클래스의 기능을 확장하는 일입니다.**   
    
스프링 배치 프로젝트에서는 각각의 상황에 맞는 다양한 ItemReader 구현체를 제공합니다.   
그중 하나가 리스트 타입으로 Reader를 구현한 ListItemReader 객체입니다.   
기존 저희가 만들었던 QueueItemReader 와 동일한 역할을 합니다.  

**InactiveUserJobConfig ListItemReader로 수정**
```java
...
    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(){
        // 그냥 여기서 처리해도 되는데 ItemReader<T>를 구현한 클래스를 반환
        // 다형성으로 ItemReader<T>에서 받아서 처리할 것이다.
        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(oldUsers); // 여러개를 받아왔구
    }
...    
```
ListItemReader 객체를 사용하도록 구현했으니 기존 QueueItemReader 객체는 삭제해도 됩니다.  
ListItemReader 객체를 사용하면 모든 데이터를 한번에 가져와 메모리에 올려놓고 read() 메서드로 하나씩 배치 처리 작업을 수행할 수 있습니다.  
  
___   

그런데 수백, 수천을 넘어 수십만 개 이상의 데이터를 한번에 가져와 메모리에 올려놓아야 할 때는 어떻게 할까요?   
이때는 배치 프로젝트에서 제공하는 PagingItemReader 구현체를 사용할 수 있습니다.   
구현체는 크게 아래와 같이 있습니다.    
     
* JdbcPagingItemReader     
* JpaPagingItemReader    
* HibernatePagingItemReader    
   
저희는 지금 JPA를 이용하고 있으므로 JpaPagingItemReader 를 사용하겠습니다.  
JpaPagingItemReader 에서는 지정한 데이터 크기만큼 DB에서 읽어오는 setPageSize() 메서드라는 기능이 있습니다.   
즉, 모든 데이터를 한번에 가져오는 것이 아니랄 지정한 단위로 가져와 배치 처리를 수행합니다.   

```
ibatisPagingReader 도 있었지만 삭제되었습니다.      
ibatisPagingReader 대신 JdbcPagingReader를 이용합시다.   
```
     
**InactiveUserJobConfig JpaPagingItemReader 추가**    
```java
package com.community.batch.jobs;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.readers.QueueItemReader;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @Autowired
    private UserRepository userRepository; // 값 읽기 재등록을 위한 클래스

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserJpaReader()) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(){ // 리더 값을 받아온다.
        // 그냥 여기서 처리해도 되는데 ItemReader<T>를 구현한 아이템 리더를 반환
        // 다형성으로 ItemReader<T>에서 받아서 처리할 것이다.
        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(oldUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader<>();
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    public ItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        return ((List<? extends User> users) -> userRepository.saveAll(users));
    }

}
```
    
___
    
```java
    @Bean(destroyMethod="")
```
스프링에서 destroyMethod 를 사용해 삭제할 빈을 자동으로 추적합니다.   
```destroyMethod=""``` 와 같이 하여 기능을 사용하지 않도록 설정하면 실행 시 출력되는 warning 메시지를 삭제할 수 있습니다.  
   
___
   
```java

        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
```
**JpaPagingItemReader 를 사용하려면 안타깝게도 쿼리를 직접 짜서 실행하는 방법밖에는 없습니다.**    
마지막 정보 갱신 일자를 나타내는 updatedDate 파라미터와 상탯값을 나타내는 status 파라미터를 사용해 쿼리를 작성합니다.   
   
___   

```java
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
```
쿼리에서 사용된 updatedDate, status 파라미터를 Map에 추가해 사용할 파라미터를 설정합니다.   
   
___

```java
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
```
트랜잭션을 관리해줄 entityManagerFactory를 설정합니다.   
    
___

```java
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
```
한번에 읽어올 크기를 15개로 설정합니다.  
   
설정이 끝났습니다. 테스트 코드를 실행해 정삭적으로 동작하는지 확인해봅시다. -> 성공   
___
    
JpaPagingItemReader를 사용할 경우 한 가지 주의사항이 있습니다.     
바로 ```CHUNK_SIZE```입니다.     
JpaPagingItemReader 는 내부에 entityManager 를 할당받아 사용하는데 지정한 크기로 데이터를 읽어옵니다.     
만약 inactiveJobStep()에서 설정한 청크 단위 (커밋 단위)가 5라고 가정하면 Item을 5개를 write까지 배치처리를 진행하고 저장한다고 해봅시다.      

저장된 데이터를 바탕으로 다음에 다시 지정한 크기로 새 인덱스를 할당해 읽어 와야 하는데   
이전에 진행한 5라는 인덱스값을 그대로 사용해 데이터를 불러오도록 로직이 짜여 있어서 문제가 됩니다.    
예를 들어 청크 단위로 5개를 커밋하고 다음 청크 단위로 넘어가야하는 경우를 가정하겠습니다.   
하지만 entityManager에서 앞서 처리된 Item 5개 때문에 새로 불러올 Item의 인덱스 시작점이 5로 설정 되어있게 됩니다.    
그러면 쿼리 요청 시 offset 5, limit 5 이므로 개념상 바로 다음 청크 단위인 Item을 건너뛰는 상황이 발생합니다.  

이러한 상황에서 가장 간단한 해결 방법은 조회용 인덱스값을 항상 0으로 반환하는 것입니다.   
0으로 반환하면 Item 5개를 수정하고 다음 5개를 건너뛰지 않고 원하는 순서/청크 단위로 처리가 가능해집니다.   

**0으로 반환**
```java
@Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }
```

**전체 코드**
```java
package com.community.batch.jobs;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.readers.QueueItemReader;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @Autowired
    private UserRepository userRepository; // 값 읽기 재등록을 위한 클래스

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserJpaReader()) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(){ // 리더 값을 받아온다.
        // 그냥 여기서 처리해도 되는데 ItemReader<T>를 구현한 아이템 리더를 반환
        // 다형성으로 ItemReader<T>에서 받아서 처리할 것이다.
        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(oldUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    public ItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        return ((List<? extends User> users) -> userRepository.saveAll(users));
    }

}
```
이외에도 JdbcPagingItemReader, HibernatePagingItemReader 등 다양한 Reader 구현체가 있습니다.   
상황에 맞게 알맞은 구현체를 선택해 사용해보기 바랍니다.    

## 6.2. 다양한 ItemWriter 구현 클래스  
ItemWriter 도 ItemReader와 마찬가지로 상황에 맞는 여러 구현 클래스를 제공합니다.       
Reader 와 마찬가지로 JPA 를 사용하고 있으므로 JpaItemWriter를 적용합니다.           

InactiveUserJobConfig 의 ItemWriter 부분을 아래와 같이 수정해줍시다.   

**ItemWriter 수정**
```java
    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }
```

**InactiveUserJobConfig**
```java
package com.community.batch.jobs;

import com.community.batch.domain.User;
import com.community.batch.domain.enums.UserStatus;
import com.community.batch.jobs.readers.QueueItemReader;
import com.community.batch.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JpaItemWriter;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.support.ListItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// 실행할 JOB 배치
@Configuration
public class InactiveUserJobConfig {

    private final static int CHUNK_SIZE = 15;

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @Autowired
    private UserRepository userRepository; // 값 읽기 재등록을 위한 클래스

    @Bean // Job 을 빈등록 한다는 의미
    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory , Step inactiveJobStep) {
        return jobBuilderFactory.get("inactiveUserJob") // inactiveUserJob 이라는 Job 생성
                .preventRestart() // 재실행, 중복실행 방지
                .start(inactiveJobStep) // step 실행
                .build(); // 빌드
    }

    @Bean // 스탭을 빈 등록한다는 의미
    public Step inactiveJobStep(StepBuilderFactory stepBuilderFactory){
        return stepBuilderFactory.get("inactiveUserStep")// inactiveUserStep 이라는 Step 생성
                .<User, User> chunk(CHUNK_SIZE) // 10 사이즈마다.
                .reader(inactiveUserJpaReader()) // 읽기
                .processor(inactiveUserProcessor()) // 프로세서
                .writer(inactiveUserWriter()) // 작성
                .build();
    }

    @Bean
    @StepScope
    public ListItemReader<User> inactiveUserReader(){ // 리더 값을 받아온다.
        // 그냥 여기서 처리해도 되는데 ItemReader<T>를 구현한 아이템 리더를 반환
        // 다형성으로 ItemReader<T>에서 받아서 처리할 것이다.
        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE);
        return new ListItemReader<>(oldUsers); // 여러개를 받아왔구
    }

    @Bean(destroyMethod="")
    @StepScope
    public JpaPagingItemReader<User> inactiveUserJpaReader(){
        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader(){
            @Override
            public int getPage() {
                return 0;
            }
        };
        jpaPagingItemReader.setQueryString(
                "select u from User as u where u.updatedDate < :updatedDate and u.status = :status");
        Map<String, Object> map = new HashMap<>();
        LocalDateTime now = LocalDateTime.now();
        map.put("updatedDate", now.minusYears(1));
        map.put("status", UserStatus.ACTIVE);

        jpaPagingItemReader.setParameterValues(map);
        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);
        jpaPagingItemReader.setPageSize(CHUNK_SIZE);
        return jpaPagingItemReader;
    }


    public ItemProcessor<User, User> inactiveUserProcessor(){
        // return User::setInactive;
        // 최신 람다 표현식
        // 인터페이스를 사용하는데 전달된 인자의 메소드만 사용할 경우 이렇게 사용해도 된다.
        // 즉 new ItemProcessor 인터페이스가 1개 있는데
        // 그 인터페이스의 인자로 User 객체가 들어가고
        // 메서드 내부에 사용되는 것이 User 객체의 setInactive 메서드라는 것이다.

        return new ItemProcessor<User, User>() {
            @Override
            public User process(User user) throws Exception {
                return user.setInactive(); // 받아온 아이템들을 inactive 처리
            }
        };
    }

    private JpaItemWriter<User> inactiveUserWriter(){ // 저징 구문 입력
        JpaItemWriter<User> jpaItemWriter = new JpaItemWriter<>();
        jpaItemWriter.setEntityManagerFactory(entityManagerFactory);
        return jpaItemWriter;
    }

}
```
JpaItemWriter는 별도로 저장 설정을 할 필요 없이 제네릭에 저장할 타입을 명시하고     
EntityManagerFactory 만 설정하면 Processor에서 넘어온 데이터를 청크 단위로 저장합니다.     
      
이밖에도 JdbcBatchItemWriter, HibernateItemWriter 등 여러 Writer 구현 클래스가 있습니다.    

## 6.3. JobParameter 사용하기   
JobParameter 를 사용해 Step 을 실행시킬 때 동적으로 파라미터를 주입시킬 수 있습니다.     

휴면회원으로 전환하는 배치 로직에서 현재 시간 기준으로 1년 전의 날짜를 값으로 사용해 휴면전환 User를 조회했습니다.      
이 경우 청크 단위로 Reader가 실행될 때마다 미세하게 현재 날짜값이 차이가 날 수 있습니다.       
JobParameter 에 현재 날짜 시간을 주입해 Reader 가 실행될 때마다 모두 동일한 시간을 참조하게 설정해봅시다.       

먼저 테스트 코드에 JobParameter 를 생성해 JobLauncher에 전달하게끔 수정합니다.    

**InactiveUserJobTest**
```java
package com.community.batch;

import com.community.batch.repository.UserRepository;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.test.JobLauncherTestUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.time.LocalDateTime;
import java.util.Date;

import static org.junit.Assert.assertEquals;
import static com.community.batch.domain.enums.UserStatus.ACTIVE;


@RunWith(SpringRunner.class)
@SpringBootTest
public class InactiveUserJobTest {

    @Autowired
    private JobLauncherTestUtils jobLauncherTestUtils;

    @Autowired
    private UserRepository userRepository;

    @Test
    public void 휴면_회원_전환_테스트() throws Exception {
        Date nowDate = new Date();
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(
                new JobParametersBuilder().addDate("nowDate", nowDate)
                .toJobParameters());

        assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());
        assertEquals(11, userRepository.findAll().size());
        assertEquals(0, userRepository.findByUpdatedDateBeforeAndStatusEquals(LocalDateTime.now().minusYears(1), ACTIVE).size());
    }
}
```
   
___
   
```java
        Date nowDate = new Date();
```
현재 날짜를 Date 타입으로 생성합니다.   
Date 타입은 JobParameter 에서 허용하는 파라미터 중 하나입니다.   
   
___

```java
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(
                new JobParametersBuilder().addDate("nowDate", nowDate)
                .toJobParameters());
```
JobParametersBuilder 를 사용하면 간편하게 JobParameters를 생성할 수 있습니다.   
JobParameters는 여러 JobParameter 를 받는 객체입니다.     
JobLauncher를 사용하려면 JobParameters가 필요합니다.   
